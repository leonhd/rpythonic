## generated by RPythonic 0.4.4
## http://code.google.com/p/rpythonic/
import os, sys, ctypes, inspect
__os = os
__sys = sys
__inspect = inspect

IS32BIT = (ctypes.sizeof(ctypes.c_void_p)==4)
PYTHON_RESERVED_KEYWORDS = 'for while in as global with try except lambda return raise if else elif eval exec and not or break continue finally print yield del def class assert from is pass'.split()

## try to load precompiled c-libraries from this directory, if the library is not there try to load from the system.
_clibs_dir = os.path.dirname(os.path.abspath(__file__))

def _load_ctypes_lib( name ):
	if __os.name == 'posix':
		if __sys.platform=='linux2':
			if not name.endswith('.so'): name += '.so'
			if not name.startswith('lib'): name = 'lib' + name

			if IS32BIT: 	path = __os.path.join(_clibs_dir,'linux32')
			else: 		path = __os.path.join(_clibs_dir,'linux64')
			url = __os.path.join( path, name )
			if __os.path.isfile( url ): return ctypes.CDLL(url)
			elif __os.path.isfile( '/usr/local/lib/%s'%name ): return ctypes.CDLL('/usr/local/lib/%s'%name)
			elif __os.path.isfile( '/usr/local/lib64/%s'%name ) and not IS32BIT: return ctypes.CDLL('/usr/local/lib64/%s'%name)
			elif __os.path.isfile( '/usr/lib/%s'%name ): return ctypes.CDLL('/usr/lib/%s'%name)
			elif __os.path.isfile( './%s'%name ): return ctypes.CDLL('./%s'%name)
			else:	# fallback
				try: return ctypes.CDLL(name)
				except: return ctypes.CDLL('')

		elif sys.platform == 'darwin':
			name += '.dylib'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'osx32')
			else: 		path = os.path.join(_clibs_dir,'osx64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			else: return ctypes.CDLL(name) #fallback

	elif os.name == 'nt':
		name += '.dll'
		if IS32BIT: 	path = os.path.join(_clibs_dir,'win32')
		else: 		path = os.path.join(_clibs_dir,'win64')
		url = os.path.join( path, name )
		if os.path.isfile( url ): return ctypes.CDLL(url)
		else: return ctypes.CDLL(name) #fallback

RPYTHONIC_WRAPPER_FUNCTIONS = {}
RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES = []
RPYTHONIC_AUTOPREFIX_IGNORE = []

## ctypes does not clearly expose these types ##
PyCFuncPtrType = type(ctypes.CFUNCTYPE(ctypes.c_void_p))
PyCArrayType = type( ctypes.c_int * 2 )
PyCPointerType = type( ctypes.POINTER(ctypes.c_int) )
PyCStructType = type( ctypes.Structure )
CArgObject = type( ctypes.byref(ctypes.c_int()) )

class _rpythonic_meta_(object):
	'''
	Reserved Attributes:
		POINTER
		CSTRUCT
		CAST
	'''
	_rpythonic_ = True		# workaround for now, must have a way to know if object is a meta from another module, isinstance(o,_rpythonic_meta_) will fail in those cases. another workaround could be check sys.modules for other rpythonic modules and fetch _rpythonic_meta_ from there.
	def __init__(self, *args, **kw ):							# cheap trick, abuse **kw, and look for "pointer", "cast"
		if kw and 'pointer' not in kw: raise SyntaxError	# sorry, you can not init with keywords
		elif kw and 'pointer' in kw:
			if 'cast' in kw and kw['cast']:
				self.POINTER = ctypes.cast( kw['pointer'], ctypes.POINTER(self.CSTRUCT) )
			else: self.POINTER = kw['pointer']
		else: self.POINTER = ctypes.pointer( self.CSTRUCT(*args) )
		self.POINTER.pyobject = self	# .pyobject is local to this pointer "object"

	def __getattr__(self,name):
		if hasattr( self.POINTER.contents, name ):
			return getattr( self.POINTER.contents, name )

		else:	# when rpythonic failed to generate good bindings - these lookups should be cached
			for parent in self._rpythonic_parent_classes_:
				if hasattr( parent, name ):
					method = getattr( parent, name )	# should check if it really is an unbound method
					func = parent._rpythonic_unbound_lookup_[ method ]
					n = func.name
					if len(func.argnames) > 1:
						argnames = func.argnames[ 1 : ]
						a = ',' + '=None,'.join( argnames ) + '=None'
						b = ','.join( argnames )
					else: a = b = ''
					lamb = eval( 'lambda self %s: %s( self.POINTER, %s )' %(a,n,b) )
					setattr( self.__class__, name, lamb )
					#return lamb	# this would return the unbound lambda, must call getattr again
					return getattr( self, name )

			## last resort, load from global name space ##
			G = globals()
			if name in G: return lambda *args: G[name](self.POINTER, *args)
			else:
				for prefix in self._autoprefix_:
					n = prefix + name
					if n in G: return lambda *args: G[n](self.POINTER, *args)
				print( 'possible auto-prefixes available', self._autoprefix_ )
				raise AttributeError

	def __call__(self, type=False):
		print('calling object is DEPRECATED - use ob.POINTER or ob.CSTRUCT')
		if type: return self.CSTRUCT
		else: return self.POINTER


def _rpythonic_generate_subclass_( name, struct, functions ):
	head = 'class %s( _rpythonic_meta_ ):' %name
	body = [ 
		'_rpythonic_parent_classes_ = []' ,
		'_rpythonic_unbound_lookup_ = {}' 
	]

	names = [ func.name for func in functions ]

	possibles = {}
	rank = []		# rank by longest name
	if len(names) > 3000: print('too many functions to use this hack')
	else:
		for n1 in names:
			prefix = ''
			for i,char in enumerate(n1):
				prefix += char
				if prefix not in possibles:
					possibles[ prefix ] = 0
					for n2 in names:
						if n2.startswith( prefix ):
							possibles[ prefix ] += 1

					if not rank or len(prefix) > len(rank[-1]) and possibles[prefix] > len(names)/4:
						rank.append( prefix )

	top = []
	while rank:
		best = rank.pop()
		if possibles[best] > len(functions)/2 and best not in names:
			if best.endswith('_set_') or best.endswith('_get_'): best = best[ : -4 ]
			elif best.endswith('Set') or best.endswith('Get'): best = best[ : -3 ]

			rem = []
			for other in rank:
				if best.startswith(other): rem.append( other )
			for r in rem: rank.remove( r )

			if best not in top: top.append( best )

		if len(top) > 3: break

	for n in names:		# find shortest prefixes #
		prefix = ''
		for i,char in enumerate(n):		# cammelCase
			if i==0: prefix += char; continue
			if char.isupper() and len(prefix) >= 2: break
			prefix += char
		if prefix and prefix != n and len(prefix) >= 2:
			hits = 0
			for other in names:
				if other.startswith( prefix ): hits += 1
			if hits >= 2 and prefix not in top:
				top.append( prefix )
				if len(top) >= 6: break

	## setup full names
	for func in functions:
		n = func.name
		if len(func.argnames) > 1:
			argnames = func.argnames[ 1 : ]
			a = ',' + '=None,'.join( argnames ) + '=None'
			b = ','.join( argnames )
		else: a = b = ''

		fhead = 'def %s( self %s ):' %(n,a)
		fbody = ['return %s(self.POINTER, %s)' %(func.name,b)]
		g = fhead + '\n\t\t' + '\n\t\t'.join( fbody )
		body.append( g )
		#body.append( '%s._rpythonic_function_ = %s' %(func.name, func.name) )

	## setup short names ##
	for n in names:
		for prefix in top:
			if n.startswith(prefix) and n[len(prefix):] not in names:
				alt = n[ len(prefix) : ]
				if alt and alt != n and alt not in PYTHON_RESERVED_KEYWORDS and not alt.isdigit() and not alt[0].isdigit():
					body.append( '%s = %s' %(alt,n) )
					names.append( alt )

	gen = head + '\n\t' + '\n\t'.join( body )
	try: exec( gen )
	except:
		print( gen )
		raise SyntaxError

	klass = locals()[name]
	klass.CSTRUCT = struct	# ctypes struct class

	klass._autoprefix_ = top
	for func in functions:
		unbound = getattr( klass, func.name )
		klass._rpythonic_unbound_lookup_[ unbound ] = func
		# klass.longname is klass.shortname = False
		# klass.longname == klass.shortname = True
	return klass

def _rpythonic_convert_structs_to_objects():
	G = globals()
	for klass in _OOAPI_:
		altname = name = klass.__name__
		prefix = ''
		for i,char in enumerate(name):
			if i==0: prefix += char; continue
			if char.isupper(): break
			prefix += char
		if prefix and prefix != name:
			hits = 0
			for other in _OOAPI_:
				if other is not klass:
					if other.__name__.startswith( prefix ): hits += 1
			if hits >= 2:
				altname = name[ len(prefix) : ]

		funcs = _OOAPI_[ klass ]
		newklass = _rpythonic_generate_subclass_( altname, klass, funcs )
		klass._rpythonic_wrapper_class_ = newklass
		G[ name ] = newklass	# replace struct with wrapper
		if altname not in G: G[ altname ] = newklass	# safely define with nicer name
		elif altname != name: # odd cases, maybe a function that returns the object, almost never happens.
			print('WARN - not replacing something with struct wrapper:', G[altname] )


def _rpythonic_setup_return_wrappers():
	R = _rpythonic_function_
	for klass in _OOAPI_:
		if klass in _OOAPI_RETURNS_OBJECT_:
			for f in _OOAPI_RETURNS_OBJECT_[klass]:
				f.object_oriented = True
				if not f.return_wrapper:	# just in case the ctypes footer defines it
					f.return_wrapper = klass._rpythonic_wrapper_class_

def _rpythonic_function_( name, result=ctypes.c_void_p, args=[]):
	mname = '_metafunc_%s' %name
	exec( 'class %s( _rpythonic_metafunc_ ): pass' %mname )
	k = locals()[mname]
	return k( name, result, args )

_OOAPI_ = {}
_OOAPI_RETURNS_OBJECT_ = {}

class _rpythonic_metafunc_(object):
	def __init__(self, name, result=ctypes.c_void_p, args=[]):
		self.name = name
		self.result = result
		self.argtypes = []		# can dynamically change CFUNCTYPE trick
		self.argnames = []
		self.argtypestypes = []
		for i,arg in enumerate(args):
			n,t = arg
			if n in PYTHON_RESERVED_KEYWORDS: n = 'C_'+n
			if n in self.argnames: n = '%s%s' %(n,i)
			self.argnames.append( n )
			self.argtypes.append( t )
			self.argtypestypes.append( type(t) )		# precomputed for speed

		self.argnames = tuple( self.argnames )				# should never change
		self.numargs = len( self.argtypes )
		self.callbacks = [None] * self.numargs
		self.return_wrapper = None
		self.object_oriented = False
		self.function = None
		try:
			func = self.function = getattr(CTYPES_DLL, self.name )
			RPYTHONIC_WRAPPER_FUNCTIONS[ name ] = self
		except:
			RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES.append( name )
		if self.function: self.reset()

	def change_argument_type( self, name, t ):
		idx = self.argnames.index( name )
		self.argtypes[ idx ] = t
		self.argtypestypes[ idx ] = type(t)
		self.function.argtypes = self.argtypes

	def reset(self):
		if self.argnames:
			a = ',' + '=None,'.join( self.argnames ) + '=None'
			b = ','.join( self.argnames )
		else: a = b = ''

		callmeth = eval( 'lambda self %s: self._call_( %s )' %(a,b) )
		setattr( self.__class__, '__call__', callmeth )

		self.function.restype = self.result
		self.function.argtypes = self.argtypes

		if type( self.result ) is PyCPointerType and type(self.result._type_) is PyCStructType:
			klass = self.result._type_
			if klass not in _OOAPI_RETURNS_OBJECT_: _OOAPI_RETURNS_OBJECT_[klass] = []
			_OOAPI_RETURNS_OBJECT_[klass].append( self )

		self.defaults = []
		for i in range( self.numargs ):
			T = self.argtypes[ i ]
			if type(T) is PyCFuncPtrType:
				p = T()	# func pointers can not be None
				self.defaults.append( p )
				self.callbacks[ i ] = p					# save reference
			elif T in (ctypes.c_int, ctypes.c_uint, ctypes.c_long, ctypes.c_ulong):
				self.defaults.append( 0 )
			elif T in (ctypes.c_float, ctypes.c_double):
				self.defaults.append( .0 )
			else: self.defaults.append( None )	# None is allowed for all other types

			## generate OO API ##
			if i == 0 and type(T) is PyCPointerType and type(T._type_) is PyCStructType:
				klass = T._type_
				if klass not in _OOAPI_: _OOAPI_[ klass ] = []
				_OOAPI_[ klass ].append( self )

	def _call_( self, *args ):			# allow flexible calling types
		cargs = list( self.defaults )
		for i,arg in enumerate(args):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER
			elif hasattr( arg, '_rpythonic_' ): arg = arg.POINTER		# workaround - instance from another module

			t = type(arg)
			k = self.argtypes[ i ]
			kt = self.argtypestypes[ i ]
			if arg is None and cargs[i] is not None:	# use user defaults, very rare cases
				continue

			elif t is bool and k is ctypes.c_int:
				if arg: cargs[i] = 1	#ctypes.c_int(1)
				else: cargs[i] = 0	#ctypes.c_int(0)

			elif t in (list,tuple):				# convert lists and tuples into array
				if kt is PyCArrayType:
					cargs[ i ] = k(*arg)
				elif kt is PyCStructType:
					if k._array_wrapper_: cargs[ i ] = k(arg)	# allow easy array init
					else: cargs[ i ] = k(*arg)							# allow multiple args
				elif kt is PyCPointerType:
					cargs[ i ] = _convert_nested_list_to_pointer( k, arg )
				else: assert 0

			elif isinstance( arg, ctypes._Pointer ) and t is not k and kt is PyCPointerType:
				cargs[ i ] = ctypes.cast( arg, k )		# generic's that need to be cast

			elif kt is PyCStructType and isinstance( arg, ctypes._Pointer ):
				cargs[ i ] = arg.contents	# fixed may25

			elif kt is PyCPointerType and not isinstance( arg, (ctypes._Pointer,CArgObject) ):
				if t in (int,float,bool): ptr = k( k._type_(arg) )
				elif t is str:
					arg = arg.encode('utf-8')
					#ptr = k( k._type_() )								# not k() otherwise null pointer error
					#for j, char in enumerate(arg): ptr[ j ] = char		# not correct - missing null byte?
					ptr = ctypes.create_string_buffer(arg)				# correct and pypy compatible
				elif t in (PyCStructType, PyCArrayType):
					ptr = ctypes.cast( ctypes.pointer( arg ), k )
				else:
					ptr = arg	# TODO print warning?
				cargs[ i ] = ptr

			elif kt is PyCFuncPtrType:
				if t.__name__ == 'CFunctionType': cargs[ i ] = arg		# assume outside holds pointer
				else:													# this is not safe #
					cargs[ i ] = self.callbacks[ i ] = k( arg )				# assume arg is a callable
			else:
				cargs[ i ] = arg		# directly pass

		## if you define your own return_wrapper, it must take keyword "pointer"
		if self.return_wrapper: return self.return_wrapper( pointer=self.function( *cargs ) )
		else: return self.function( *cargs )



def _convert_nested_list_to_pointer( k, arg ):
	depth = 0; s = k
	while True:
		if type(s) is PyCPointerType:
			s = getattr( s, '_type_' )
			depth += 1
		else: break
	assert depth and depth <= 2
	if depth == 1:
		T = k._type_
		ptr = k( k._type_() )
		for i in range( len(arg) ):
			ptr[ i ] = T( *arg[i] )
	elif depth == 2:
		T = k._type_._type_
		_ptr = k._type_( k._type_._type_() )
		for i in range(len( arg )):
			for j in range( len(arg[i]) ):
				_ptr[ j ] = T( *arg[ i ][ j ] )
		ptr = k( _ptr )
	return ptr


def __freeze_rpythonic_struct( cls, fields ):
	if cls not in _OOAPI_: _OOAPI_[ cls ] = []	# wrap all structs
	try: setattr( cls, '_fields_', fields )
	except:
		print( 'WARN - bad order struct freeze', cls )
		#cls._fields_ = []

class _rpythonic_struct_( ctypes.Structure ):
	_array_wrapper_ = False
	_fields_ = []
	_methods_ = {}
	#def __call__(self): return self
	def __init__(self, *args, **kw ):
		cargs = []
		argtypes = []
		for a in self._fields_: argtypes.append( a[1] )
		if len(args) > len(argtypes): args = [args]	# allow both calling conventions
		for i,arg in enumerate( args ):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER

			t = type(arg)
			k = argtypes[ i ]
			if t in (list,tuple):
				if k.__class__.__name__	== 'PyCArrayType':
					cargs.append( k(*arg) )
				elif k.__class__.__name__ == 'PyCStructType':
					if k._array_wrapper_: cargs.append( k(arg) )	# allow easy array init
					else: cargs.append( k(*arg) )							# allow multiple args
			elif isinstance( arg, ctypes._Pointer ) and t is not k:
				cargs[ i ] = ctypes.cast( arg, k )	# generic's that need to be cast
			elif k.__class__.__name__ == 'PyCArrayType' and t in (float,int,bool):
				cargs.append( k(arg) )		# support init array from single value
			else:
				cargs.append( arg )		# directly pass

		ctypes.Structure.__init__(self, *cargs, **kw)


def _rpythonic_make_nice_global_enums_():
	G = globals()
	for name in RPYTHONIC_GLOBAL_ENUMS:
		if '_' in name and name.index('_') <= 4:
			altname = name[ name.index('_') + 1 : ]
			if altname not in G:
				G[altname] = RPYTHONIC_GLOBAL_ENUMS[ name ]

def _rpythonic_clean_up_missing_functions_():
	G = globals()
	for f in RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES:
		G.pop( f )
	print( "C functions loaded: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS) )
	print( "C functions failed: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES) )



###### NEW API #########
CTYPES_DLL = None

class _VOID_POINTER_CONTAINER_(object):
	def __init__(self, ptr, name=None):
		self._pointer_ = ptr
		self.name = name
NULL = _VOID_POINTER_CONTAINER_(None,'<null pointer>')


class meta:	# NEW API - allow run time switch from ctypes to rffi
	'''
	Methods:
		RPython will not allow object wrapper around a method (__call__ not allowed)
		keep C function names in list "__cfunctions__"
		rpythonic.enable_rffi( classA, classB )	
		can take advantage of methods in object-method-wrapper,
		generate rffi wrapper and set method on classA, etc.
		replaces object-method-wrapper with rffi-method

	Properties:
		CPython: obj.x=1
		RPython: obj.set_x(1)	
	'''
	METAS = []
	def __init__(self, constructors=[], methods={}, properties={}):
		global CTYPES_DLL
		if not CTYPES_DLL:
			CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		self.constructors = constructors
		self.methods = methods
		self.properties = properties
		self.METAS.append( self )



	def __call__(self, cls ):
		print('@meta', cls )

		if not self.constructors:
			lamb = lambda s, _explicit_pointer_=None: setattr(s,'_pointer_',getattr(_explicit_pointer_,'_pointer_')) if hasattr(_explicit_pointer_,'_pointer_') else setattr(s,'_pointer_',_explicit_pointer_)
			lamb._debug = '(no constructor)'
			setattr( cls, '__init__', lamb )
		else:
			con = self._find_best_function( self.constructors )
			cfunc = self._build_cfunc( con )
			setattr( cls, '_%s'%con['name'], cfunc )
			g = self._gen_init( con )
			setattr( cls, '__init__', g )
		
		## set methods ##
		for name in self.methods:
			meth = self.methods[ name ]
			cfuncs = []
			for m in meth['functions']:
				cfunc = self._build_cfunc( m, method=True, static=meth['static'] )
				self._setup_return( cfunc, meth )
				setattr( cls, '_%s'%m['name'], cfunc )
				cfuncs.append( cfunc )

			f = self._find_best_function( meth['functions'] )
			g = self._gen_method( meth, f )
			g._cfuncs = cfuncs
			if meth['static']: g = classmethod( g )
			setattr( cls, name, g )

		for name in self.properties:
			print( 'property:', name )
			p = []
			for f in self.properties[name]:
				cfunc = self._build_cfunc( f )
				setattr( cls, '_%s'%f['name'], cfunc )
				g = self._gen_method( f, f )
				p.append( g )

			setattr( cls, name, property(*p) )

		return cls


	@staticmethod
	def _build_cfunc( info, method=False, static=False ):
		cfunc = getattr(CTYPES_DLL, info['name'])
		if method and not static: argtypes = [ ctypes.c_void_p ]
		else: argtypes = []
		for p in info['parameters']: argtypes.append( eval(p['ctypes_type']) )
		cfunc.argtypes = argtypes
		return cfunc

	@staticmethod
	def _setup_return( cfunc, info ):
		if not info['returns_fundamental']:
			cfunc.restype = ctypes.c_void_p
		elif info['returns_fundamental']:
			cfunc.restype = eval( info['returns_ctypes'] )
		else:
			cfunc.restype = ctypes.c_void_p

	@staticmethod
	def _gen_prepare_args( m ):
		a = []; b = []
		for i,p in enumerate(m['parameters']):
			if 'name' in p: n = p['name']
			else: n = '_unnamed_%s' %i
			if '<' in n: n = '_TODOfixme_%s' %i
			if n in PYTHON_RESERVED_KEYWORDS: n += str(i)
			if p['fundamental']:
				b.append( n )
				s = p['raw_type'].split()
				if 'default' in p:
					d = p['default']
					if p['raw_type'] in ('float', 'double'):
						if d.endswith('f'): d = d[:-1]
						d = d.replace(' ', '.')
						if 'e' in d: d = 0.0
						try: d = float(d)
						except: d = 0.0
					elif ('int' in s or 'size_t' in s) and not d.isdigit(): d = 0
					elif 'char' in s and '"' not in d: d = '""'
					elif d.lower() == 'false': d = False
					elif d.lower() == 'true': d = True
				elif 'char' in s: d = '""'
				elif 'float' in s or 'double' in s: d = 0.0
				elif 'size_t' in s or 'int' in s or 'long' in s or 'short' in s: d = 0
				elif p['raw_type'] == 'bool': d = False
				elif p['raw_type'] in ('void', '(template)'): d = 'NULL'
				else: print( p )
				a.append( n+'=%s' %d )

			else:
				b.append( '%s._pointer_'%n )
				a.append( n+'=NULL' )
		return a, b

	@staticmethod
	def _gen_init( m ):
		a, b = meta._gen_prepare_args( m )
		if a: e = 'lambda _py_self_, %s, _explicit_pointer_=None: ' %(','.join(a))
		else: e = 'lambda _py_self_, _explicit_pointer_=None: '
		e += 'setattr(_py_self_, "_pointer_", _py_self_._%s(%s))' %( m['name'], ','.join(b) )
		e += ' if not _explicit_pointer_ else '
		e += 'setattr(_py_self_, "_pointer_", _explicit_pointer_)'
		print( e )
		lamb = eval( e ); lamb._debug = e; lamb._introspect = m
		return lamb

	@staticmethod
	def _find_best_function( funcs ):
		best = funcs[0]
		score = -1
		if len(funcs) > 1:
			for f in funcs:
				hits = 0
				for p in f['parameters']:
					if p['fundamental']: hits += 1
				if hits and hits == len( f['parameters'] ):
					if hits > score:
						score = hits
						best = f
		return best

	@staticmethod
	def _gen_method( m, f ):
		a, b = meta._gen_prepare_args( f )
		if a: e = 'lambda _py_self_, %s: ' %(','.join(a))
		else: e = 'lambda _py_self_: '

		if 'static' in m and m['static']:	# static in c++ is like a classmethod
			c = '_py_self_._%s( %s )' %( f['name'], ','.join(b) )
		else:
			c = '_py_self_._%s( _py_self_._pointer_, %s )' %( f['name'], ','.join(b) )

		if not m['returns_fundamental']:
			if 'returns_unknown' in m or '<' in m['returns']: c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,m['returns'])
			else:
				something = m['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)

		e += c; lamb = eval( e )
		lamb._debug = e; lamb._introspect = f
		return lamb


	META_FUNCTIONS = []
	@classmethod
	def function( self, info ):
		print('@meta.function', info['name'] )
		global CTYPES_DLL
		if not CTYPES_DLL:
			CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		cfunc = self._build_cfunc( info, method=False, static=True )
		setattr( meta, '_%s'%info['name'], cfunc )
		self._setup_return( cfunc, info )
		a, b = meta._gen_prepare_args( info )
		e = 'lambda %s: ' %(','.join(a))
		c = 'meta._%s( %s )' %( info['name'], ','.join(b) )

		if not info['returns_fundamental']:
			if 'returns_unknown' in info or '<' in info['returns']:
				c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,info['returns'])
			else:
				something = info['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)
		e += c
		lamb = eval( e )
		lamb._debug = e
		lamb._introspect = info
		return lamb



def _rpythonic_strip_prefixes_( prefixes ):
	G = globals()
	names = list(G.keys())	# ensure list in py3
	for name in names:
		for prefix in prefixes:
			if name.startswith( prefix ):
				newname = name[ len(prefix) : ]
				if newname and newname not in G:
					G[ newname ] = G[ name ]






_clib_name_ = 'libcv'
print('loading lib', _clib_name_)
print( os.path.abspath( os.path.curdir ) )
CTYPES_DLL = _load_ctypes_lib( _clib_name_ )
assert CTYPES_DLL
print( CTYPES_DLL._name )

## macro globals ##
CV_BLUR_NO_SCALE = 0
CV_BLUR = 1
CV_GAUSSIAN = 2
CV_MEDIAN = 3
CV_BILATERAL = 4
CV_INPAINT_NS = 0
CV_INPAINT_TELEA = 1
CV_SCHARR = -1
CV_MAX_SOBEL_KSIZE = 7
CV_BGR2BGRA = 0
CV_RGB2RGBA = 0
CV_BGRA2BGR = 1
CV_RGBA2RGB = 1
CV_BGR2RGBA = 2
CV_RGB2BGRA = 2
CV_RGBA2BGR = 3
CV_BGRA2RGB = 3
CV_BGR2RGB = 4
CV_RGB2BGR = 4
CV_BGRA2RGBA = 5
CV_RGBA2BGRA = 5
CV_BGR2GRAY = 6
CV_RGB2GRAY = 7
CV_GRAY2BGR = 8
CV_GRAY2RGB = 8
CV_GRAY2BGRA = 9
CV_GRAY2RGBA = 9
CV_BGRA2GRAY = 10
CV_RGBA2GRAY = 11
CV_BGR2BGR565 = 12
CV_RGB2BGR565 = 13
CV_BGR5652BGR = 14
CV_BGR5652RGB = 15
CV_BGRA2BGR565 = 16
CV_RGBA2BGR565 = 17
CV_BGR5652BGRA = 18
CV_BGR5652RGBA = 19
CV_GRAY2BGR565 = 20
CV_BGR5652GRAY = 21
CV_BGR2BGR555 = 22
CV_RGB2BGR555 = 23
CV_BGR5552BGR = 24
CV_BGR5552RGB = 25
CV_BGRA2BGR555 = 26
CV_RGBA2BGR555 = 27
CV_BGR5552BGRA = 28
CV_BGR5552RGBA = 29
CV_GRAY2BGR555 = 30
CV_BGR5552GRAY = 31
CV_BGR2XYZ = 32
CV_RGB2XYZ = 33
CV_XYZ2BGR = 34
CV_XYZ2RGB = 35
CV_BGR2YCrCb = 36
CV_RGB2YCrCb = 37
CV_YCrCb2BGR = 38
CV_YCrCb2RGB = 39
CV_BGR2HSV = 40
CV_RGB2HSV = 41
CV_BGR2Lab = 44
CV_RGB2Lab = 45
CV_BayerBG2BGR = 46
CV_BayerGB2BGR = 47
CV_BayerRG2BGR = 48
CV_BayerGR2BGR = 49
CV_BayerBG2RGB = 48
CV_BayerGB2RGB = 49
CV_BayerRG2RGB = 46
CV_BayerGR2RGB = 47
CV_BGR2Luv = 50
CV_RGB2Luv = 51
CV_BGR2HLS = 52
CV_RGB2HLS = 53
CV_HSV2BGR = 54
CV_HSV2RGB = 55
CV_Lab2BGR = 56
CV_Lab2RGB = 57
CV_Luv2BGR = 58
CV_Luv2RGB = 59
CV_HLS2BGR = 60
CV_HLS2RGB = 61
CV_COLORCVT_MAX = 100
CV_INTER_NN = 0
CV_INTER_LINEAR = 1
CV_INTER_CUBIC = 2
CV_INTER_AREA = 3
CV_WARP_FILL_OUTLIERS = 8
CV_WARP_INVERSE_MAP = 16
CV_SHAPE_RECT = 0
CV_SHAPE_CROSS = 1
CV_SHAPE_ELLIPSE = 2
CV_SHAPE_CUSTOM = 100
CV_MOP_ERODE = 0
CV_MOP_DILATE = 1
CV_MOP_OPEN = 2
CV_MOP_CLOSE = 3
CV_MOP_GRADIENT = 4
CV_MOP_TOPHAT = 5
CV_MOP_BLACKHAT = 6
CV_TM_SQDIFF = 0
CV_TM_SQDIFF_NORMED = 1
CV_TM_CCORR = 2
CV_TM_CCORR_NORMED = 3
CV_TM_CCOEFF = 4
CV_TM_CCOEFF_NORMED = 5
CV_LKFLOW_PYR_A_READY = 1
CV_LKFLOW_PYR_B_READY = 2
CV_LKFLOW_INITIAL_GUESSES = 4
CV_LKFLOW_GET_MIN_EIGENVALS = 8
CV_POLY_APPROX_DP = 0
CV_CONTOURS_MATCH_I1 = 1
CV_CONTOURS_MATCH_I2 = 2
CV_CONTOURS_MATCH_I3 = 3
CV_CONTOUR_TREES_MATCH_I1 = 1
CV_CLOCKWISE = 1
CV_COUNTER_CLOCKWISE = 2
CV_COMP_CORREL = 0
CV_COMP_CHISQR = 1
CV_COMP_INTERSECT = 2
CV_COMP_BHATTACHARYYA = 3
CV_VALUE = 1
CV_ARRAY = 2
CV_DIST_MASK_3 = 3
CV_DIST_MASK_5 = 5
CV_DIST_MASK_PRECISE = 0
CV_THRESH_BINARY = 0
CV_THRESH_BINARY_INV = 1
CV_THRESH_TRUNC = 2
CV_THRESH_TOZERO = 3
CV_THRESH_TOZERO_INV = 4
CV_THRESH_MASK = 7
CV_THRESH_OTSU = 8
CV_ADAPTIVE_THRESH_MEAN_C = 0
CV_ADAPTIVE_THRESH_GAUSSIAN_C = 1
CV_HOUGH_STANDARD = 0
CV_HOUGH_PROBABILISTIC = 1
CV_HOUGH_MULTI_SCALE = 2
CV_HOUGH_GRADIENT = 3
CV_HAAR_DO_CANNY_PRUNING = 1
CV_HAAR_SCALE_IMAGE = 2
CV_HAAR_FIND_BIGGEST_OBJECT = 4
CV_HAAR_DO_ROUGH_SEARCH = 8
CV_LMEDS = 4
CV_RANSAC = 8
CV_CALIB_CB_ADAPTIVE_THRESH = 1
CV_CALIB_CB_NORMALIZE_IMAGE = 2
CV_CALIB_CB_FILTER_QUADS = 4
CV_CALIB_CB_FAST_CHECK = 8
CV_CALIB_USE_INTRINSIC_GUESS = 1
CV_CALIB_FIX_ASPECT_RATIO = 2
CV_CALIB_FIX_PRINCIPAL_POINT = 4
CV_CALIB_ZERO_TANGENT_DIST = 8
CV_CALIB_FIX_FOCAL_LENGTH = 16
CV_CALIB_FIX_K1 = 32
CV_CALIB_FIX_K2 = 64
CV_CALIB_FIX_K3 = 128
CV_CALIB_FIX_INTRINSIC = 256
CV_CALIB_SAME_FOCAL_LENGTH = 512
CV_CALIB_ZERO_DISPARITY = 1024
CV_FM_7POINT = 1
CV_FM_8POINT = 2
CV_FM_LMEDS_ONLY = 4
CV_FM_RANSAC_ONLY = 8
CV_FM_LMEDS = 4
CV_FM_RANSAC = 8
CV_STEREO_BM_NORMALIZED_RESPONSE = 0
CV_STEREO_BM_XSOBEL = 1
CV_STEREO_BM_BASIC = 0
CV_STEREO_BM_FISH_EYE = 1
CV_STEREO_BM_NARROW = 2
CV_RETR_EXTERNAL = 0
CV_RETR_LIST = 1
CV_RETR_CCOMP = 2
CV_RETR_TREE = 3
CV_CHAIN_CODE = 0
CV_CHAIN_APPROX_NONE = 1
CV_CHAIN_APPROX_SIMPLE = 2
CV_CHAIN_APPROX_TC89_L1 = 3
CV_CHAIN_APPROX_TC89_KCOS = 4
CV_LINK_RUNS = 5
CV_DIST_USER = -1
CV_DIST_L1 = 1
CV_DIST_L2 = 2
CV_DIST_C = 3
CV_DIST_L12 = 4
CV_DIST_FAIR = 5
CV_DIST_WELSCH = 6
CV_DIST_HUBER = 7
CV_HAAR_MAGIC_VAL = 1112539136
CV_TYPE_NAME_HAAR = "opencv-haar-classifier"
CV_HAAR_FEATURE_MAX = 3
## enums ##
CvSubdiv2DPointLocation = { 
	"CV_PTLOC_ERROR" : -2, 
	"CV_PTLOC_OUTSIDE_RECT" : -1, 
	"CV_PTLOC_INSIDE" : 0, 
	"CV_PTLOC_VERTEX" : 1, 
	"CV_PTLOC_ON_EDGE" : 2, 
}

CvNextEdgeType = { 
	"CV_NEXT_AROUND_ORG" : 0, 
	"CV_NEXT_AROUND_DST" : 34, 
	"CV_PREV_AROUND_ORG" : 17, 
	"CV_PREV_AROUND_DST" : 51, 
	"CV_NEXT_AROUND_LEFT" : 19, 
	"CV_NEXT_AROUND_RIGHT" : 49, 
	"CV_PREV_AROUND_LEFT" : 32, 
	"CV_PREV_AROUND_RIGHT" : 2, 
}

CvFilter = { 
	"CV_GAUSSIAN_5x5" : 7, 
}

CvStatus = { 
	"CV_BADMEMBLOCK_ERR" : -113, 
	"CV_INPLACE_NOT_SUPPORTED_ERR" : -112, 
	"CV_UNMATCHED_ROI_ERR" : -111, 
	"CV_NOTFOUND_ERR" : -110, 
	"CV_BADCONVERGENCE_ERR" : -109, 
	"CV_BADDEPTH_ERR" : -107, 
	"CV_BADROI_ERR" : -106, 
	"CV_BADHEADER_ERR" : -105, 
	"CV_UNMATCHED_FORMATS_ERR" : -104, 
	"CV_UNSUPPORTED_COI_ERR" : -103, 
	"CV_UNSUPPORTED_CHANNELS_ERR" : -102, 
	"CV_UNSUPPORTED_DEPTH_ERR" : -101, 
	"CV_UNSUPPORTED_FORMAT_ERR" : -100, 
	"CV_BADARG_ERR" : -49, 
	"CV_NOTDEFINED_ERR" : -48, 
	"CV_BADCHANNELS_ERR" : -47, 
	"CV_BADRANGE_ERR" : -44, 
	"CV_BADSTEP_ERR" : -29, 
	"CV_BADFLAG_ERR" : -12, 
	"CV_DIV_BY_ZERO_ERR" : -11, 
	"CV_BADCOEF_ERR" : -10, 
	"CV_BADFACTOR_ERR" : -7, 
	"CV_BADPOINT_ERR" : -6, 
	"CV_BADSCALE_ERR" : -4, 
	"CV_OUTOFMEM_ERR" : -3, 
	"CV_NULLPTR_ERR" : -2, 
	"CV_BADSIZE_ERR" : -1, 
	"CV_NO_ERR" : 0, 
	"CV_OK" : 0, 
}

## simple enums ##
RPYTHONIC_GLOBAL_ENUMS = { 

}
class Cv32suf(ctypes.Union): pass
class Cv64suf(ctypes.Union): pass
class _IplImage(_rpythonic_struct_): _array_wrapper_ = True
class _IplTileInfo(_rpythonic_struct_): pass
class _IplROI(_rpythonic_struct_): pass
class _IplConvKernel(_rpythonic_struct_): pass
class _IplConvKernelFP(_rpythonic_struct_): pass
class CvMat(_rpythonic_struct_): pass
class data(ctypes.Union): pass
class CvMatND(_rpythonic_struct_): _array_wrapper_ = True
class dim(_rpythonic_struct_): _array_wrapper_ = True
class CvSparseMat(_rpythonic_struct_): _array_wrapper_ = True
class CvSparseNode(_rpythonic_struct_): pass
class CvSparseMatIterator(_rpythonic_struct_): pass
class CvHistogram(_rpythonic_struct_): _array_wrapper_ = True
class CvRect(_rpythonic_struct_): pass
class CvTermCriteria(_rpythonic_struct_): pass
class CvPoint(_rpythonic_struct_): pass
class CvPoint2D32f(_rpythonic_struct_): pass
class CvPoint3D32f(_rpythonic_struct_): pass
class CvPoint2D64f(_rpythonic_struct_): pass
class CvPoint3D64f(_rpythonic_struct_): pass
class CvSize(_rpythonic_struct_): pass
class CvSize2D32f(_rpythonic_struct_): pass
class CvBox2D(_rpythonic_struct_): pass
class CvLineIterator(_rpythonic_struct_): pass
class CvSlice(_rpythonic_struct_): pass
class CvScalar(_rpythonic_struct_): _array_wrapper_ = True
class CvMemBlock(_rpythonic_struct_): pass
class CvMemStorage(_rpythonic_struct_): pass
class CvMemStoragePos(_rpythonic_struct_): pass
class CvSeqBlock(_rpythonic_struct_): pass
class CvSeq(_rpythonic_struct_): pass
class CvSetElem(_rpythonic_struct_): pass
class CvSet(_rpythonic_struct_): pass
class CvGraphEdge(_rpythonic_struct_): _array_wrapper_ = True
class CvGraphVtx(_rpythonic_struct_): pass
class CvGraphVtx2D(_rpythonic_struct_): pass
class CvGraph(_rpythonic_struct_): pass
class CvChain(_rpythonic_struct_): pass
class CvContour(_rpythonic_struct_): _array_wrapper_ = True
class CvSeqWriter(_rpythonic_struct_): pass
class CvSeqReader(_rpythonic_struct_): pass
class CvFileStorage(_rpythonic_struct_): pass
class CvAttrList(_rpythonic_struct_): pass
class CvString(_rpythonic_struct_): pass
class CvStringHashNode(_rpythonic_struct_): pass
class CvGenericHash(_rpythonic_struct_): pass
class CvFileNode(_rpythonic_struct_): pass
class CvTypeInfo(_rpythonic_struct_): pass
class CvPluginFuncInfo(_rpythonic_struct_): pass
class CvModuleInfo(_rpythonic_struct_): pass
class CvNArrayIterator(_rpythonic_struct_): _array_wrapper_ = True
class CvGraphScanner(_rpythonic_struct_): pass
class CvFont(_rpythonic_struct_): pass
class CvTreeNodeIterator(_rpythonic_struct_): pass
class CvFuncTable(_rpythonic_struct_): _array_wrapper_ = True
class CvBigFuncTable(_rpythonic_struct_): _array_wrapper_ = True
class CvMoments(_rpythonic_struct_): pass
class CvHuMoments(_rpythonic_struct_): pass
class CvConnectedComp(_rpythonic_struct_): pass
class _CvContourScanner(_rpythonic_struct_): pass
class CvChainPtReader(_rpythonic_struct_): _array_wrapper_ = True
class CvContourTree(_rpythonic_struct_): pass
class CvConvexityDefect(_rpythonic_struct_): pass
class CvQuadEdge2D(_rpythonic_struct_): _array_wrapper_ = True
class CvSubdiv2DPoint(_rpythonic_struct_): pass
class CvSubdiv2D(_rpythonic_struct_): pass
class CvMatrix3(_rpythonic_struct_): _array_wrapper_ = True
class CvKalman(_rpythonic_struct_): pass
class CvHaarFeature(_rpythonic_struct_): _array_wrapper_ = True
class rect(_rpythonic_struct_): _array_wrapper_ = True
class CvHaarClassifier(_rpythonic_struct_): pass
class CvHaarStageClassifier(_rpythonic_struct_): pass
class CvHidHaarClassifierCascade(_rpythonic_struct_): pass
class CvHaarClassifierCascade(_rpythonic_struct_): pass
class CvAvgComp(_rpythonic_struct_): pass
class CvFeatureTree(_rpythonic_struct_): pass
class CvLSH(_rpythonic_struct_): pass
class CvLSHOperations(_rpythonic_struct_): pass
class CvSURFPoint(_rpythonic_struct_): pass
class CvSURFParams(_rpythonic_struct_): pass
class CvMSERParams(_rpythonic_struct_): pass
class CvStarKeypoint(_rpythonic_struct_): pass
class CvStarDetectorParams(_rpythonic_struct_): pass
class CvPOSITObject(_rpythonic_struct_): pass
class CvStereoBMState(_rpythonic_struct_): pass
class CvStereoGCState(_rpythonic_struct_): pass
class CvRandState(_rpythonic_struct_): _array_wrapper_ = True
class _CvPixelPosition8u(_rpythonic_struct_): _array_wrapper_ = True
class _CvPixelPosition8s(_rpythonic_struct_): _array_wrapper_ = True
class _CvPixelPosition32f(_rpythonic_struct_): _array_wrapper_ = True
## union and structures ##
__freeze_rpythonic_struct( Cv32suf, [
	( "i", ctypes.c_int ),
	( "u", ctypes.c_void_p ),
	( "f", ctypes.c_float ),
])

__freeze_rpythonic_struct( Cv64suf, [
	( "i", ctypes.c_int64 ),
	( "u", ctypes.c_uint64 ),
	( "f", ctypes.c_double ),
])

__freeze_rpythonic_struct( _IplROI, [
	( "coi", ctypes.c_int ),
	( "xOffset", ctypes.c_int ),
	( "yOffset", ctypes.c_int ),
	( "width", ctypes.c_int ),
	( "height", ctypes.c_int ),
])

__freeze_rpythonic_struct( _IplTileInfo, [
])

__freeze_rpythonic_struct( _IplImage, [
	( "nSize", ctypes.c_int ),
	( "ID", ctypes.c_int ),
	( "nChannels", ctypes.c_int ),
	( "alphaChannel", ctypes.c_int ),
	( "depth", ctypes.c_int ),
	( "colorModel", ( ctypes.c_char * 4 ) ),
	( "channelSeq", ( ctypes.c_char * 4 ) ),
	( "dataOrder", ctypes.c_int ),
	( "origin", ctypes.c_int ),
	( "align", ctypes.c_int ),
	( "width", ctypes.c_int ),
	( "height", ctypes.c_int ),
	( "roi", ctypes.POINTER(_IplROI) ),
	( "maskROI", ctypes.POINTER(_IplImage) ),
	( "imageId", ctypes.POINTER(ctypes.c_void_p) ),
	( "tileInfo", ctypes.POINTER(_IplTileInfo) ),
	( "imageSize", ctypes.c_int ),
	( "imageData", ctypes.POINTER(ctypes.c_char) ),
	( "widthStep", ctypes.c_int ),
	( "BorderMode", ( ctypes.c_int * 4 ) ),
	( "BorderConst", ( ctypes.c_int * 4 ) ),
	( "imageDataOrigin", ctypes.POINTER(ctypes.c_char) ),
])

__freeze_rpythonic_struct( _IplConvKernel, [
	( "nCols", ctypes.c_int ),
	( "nRows", ctypes.c_int ),
	( "anchorX", ctypes.c_int ),
	( "anchorY", ctypes.c_int ),
	( "values", ctypes.POINTER(ctypes.c_int) ),
	( "nShiftR", ctypes.c_int ),
])

__freeze_rpythonic_struct( _IplConvKernelFP, [
	( "nCols", ctypes.c_int ),
	( "nRows", ctypes.c_int ),
	( "anchorX", ctypes.c_int ),
	( "anchorY", ctypes.c_int ),
	( "values", ctypes.POINTER(ctypes.c_float) ),
])

__freeze_rpythonic_struct( data, [
	( "ptr", ctypes.POINTER(ctypes.c_ubyte) ),
	( "s", ctypes.POINTER(ctypes.c_short) ),
	( "i", ctypes.POINTER(ctypes.c_int) ),
	( "fl", ctypes.POINTER(ctypes.c_float) ),
	( "db", ctypes.POINTER(ctypes.c_double) ),
])

__freeze_rpythonic_struct( CvMat, [
	( "C_type", ctypes.c_int ),
	( "step", ctypes.c_int ),
	( "refcount", ctypes.POINTER(ctypes.c_int) ),
	( "hdr_refcount", ctypes.c_int ),
	( "data", data ),
	( "rows", ctypes.c_int ),
	( "cols", ctypes.c_int ),
])

__freeze_rpythonic_struct( dim, [
	( "size", ( ctypes.c_int * 32 ) ),
	( "step", ( ctypes.c_int * 32 ) ),
])

__freeze_rpythonic_struct( CvMatND, [
	( "C_type", ctypes.c_int ),
	( "dims", ctypes.c_int ),
	( "refcount", ctypes.POINTER(ctypes.c_int) ),
	( "hdr_refcount", ctypes.c_int ),
	( "data", data ),
	( "dim", ( dim * 32 ) ),
])

__freeze_rpythonic_struct( CvMemBlock, [
	( "prev", ctypes.POINTER(CvMemBlock) ),
	( "next", ctypes.POINTER(CvMemBlock) ),
])

__freeze_rpythonic_struct( CvMemStorage, [
	( "signature", ctypes.c_int ),
	( "bottom", ctypes.POINTER(CvMemBlock) ),
	( "top", ctypes.POINTER(CvMemBlock) ),
	( "parent", ctypes.POINTER(CvMemStorage) ),
	( "block_size", ctypes.c_int ),
	( "free_space", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvSeqBlock, [
	( "prev", ctypes.POINTER(CvSeqBlock) ),
	( "next", ctypes.POINTER(CvSeqBlock) ),
	( "start_index", ctypes.c_int ),
	( "count", ctypes.c_int ),
	( "data", ctypes.POINTER(ctypes.c_char) ),
])

__freeze_rpythonic_struct( CvSeq, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "h_prev", ctypes.POINTER(CvSeq) ),
	( "h_next", ctypes.POINTER(CvSeq) ),
	( "v_prev", ctypes.POINTER(CvSeq) ),
	( "v_next", ctypes.POINTER(CvSeq) ),
	( "total", ctypes.c_int ),
	( "elem_size", ctypes.c_int ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "delta_elems", ctypes.c_int ),
	( "storage", ctypes.POINTER(CvMemStorage) ),
	( "free_blocks", ctypes.POINTER(CvSeqBlock) ),
	( "first", ctypes.POINTER(CvSeqBlock) ),
])

__freeze_rpythonic_struct( CvSetElem, [
	( "flags", ctypes.c_int ),
	( "next_free", ctypes.POINTER(CvSetElem) ),
])

__freeze_rpythonic_struct( CvSet, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "h_prev", ctypes.POINTER(CvSeq) ),
	( "h_next", ctypes.POINTER(CvSeq) ),
	( "v_prev", ctypes.POINTER(CvSeq) ),
	( "v_next", ctypes.POINTER(CvSeq) ),
	( "total", ctypes.c_int ),
	( "elem_size", ctypes.c_int ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "delta_elems", ctypes.c_int ),
	( "storage", ctypes.POINTER(CvMemStorage) ),
	( "free_blocks", ctypes.POINTER(CvSeqBlock) ),
	( "first", ctypes.POINTER(CvSeqBlock) ),
	( "free_elems", ctypes.POINTER(CvSetElem) ),
	( "active_count", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvSparseMat, [
	( "C_type", ctypes.c_int ),
	( "dims", ctypes.c_int ),
	( "refcount", ctypes.POINTER(ctypes.c_int) ),
	( "hdr_refcount", ctypes.c_int ),
	( "heap", ctypes.POINTER(CvSet) ),
	( "hashtable", ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p)) ),
	( "hashsize", ctypes.c_int ),
	( "valoffset", ctypes.c_int ),
	( "idxoffset", ctypes.c_int ),
	( "size", ( ctypes.c_int * 32 ) ),
])

__freeze_rpythonic_struct( CvSparseNode, [
	( "hashval", ctypes.c_void_p ),
	( "next", ctypes.POINTER(CvSparseNode) ),
])

__freeze_rpythonic_struct( CvSparseMatIterator, [
	( "mat", ctypes.POINTER(CvSparseMat) ),
	( "node", ctypes.POINTER(CvSparseNode) ),
	( "curidx", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvHistogram, [
	( "C_type", ctypes.c_int ),
	( "bins", ctypes.POINTER(ctypes.c_void_p) ),
	( "thresh", ( ctypes.c_float * 32 ) ),
	( "thresh2", ctypes.POINTER(ctypes.POINTER(ctypes.c_float)) ),
	( "mat", CvMatND ),
])

__freeze_rpythonic_struct( CvRect, [
	( "x", ctypes.c_int ),
	( "y", ctypes.c_int ),
	( "width", ctypes.c_int ),
	( "height", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvTermCriteria, [
	( "C_type", ctypes.c_int ),
	( "max_iter", ctypes.c_int ),
	( "epsilon", ctypes.c_double ),
])

__freeze_rpythonic_struct( CvPoint, [
	( "x", ctypes.c_int ),
	( "y", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvPoint2D32f, [
	( "x", ctypes.c_float ),
	( "y", ctypes.c_float ),
])

__freeze_rpythonic_struct( CvPoint3D32f, [
	( "x", ctypes.c_float ),
	( "y", ctypes.c_float ),
	( "z", ctypes.c_float ),
])

__freeze_rpythonic_struct( CvPoint2D64f, [
	( "x", ctypes.c_double ),
	( "y", ctypes.c_double ),
])

__freeze_rpythonic_struct( CvPoint3D64f, [
	( "x", ctypes.c_double ),
	( "y", ctypes.c_double ),
	( "z", ctypes.c_double ),
])

__freeze_rpythonic_struct( CvSize, [
	( "width", ctypes.c_int ),
	( "height", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvSize2D32f, [
	( "width", ctypes.c_float ),
	( "height", ctypes.c_float ),
])

__freeze_rpythonic_struct( CvBox2D, [
	( "center", CvPoint2D32f ),
	( "size", CvSize2D32f ),
	( "angle", ctypes.c_float ),
])

__freeze_rpythonic_struct( CvLineIterator, [
	( "ptr", ctypes.POINTER(ctypes.c_ubyte) ),
	( "err", ctypes.c_int ),
	( "plus_delta", ctypes.c_int ),
	( "minus_delta", ctypes.c_int ),
	( "plus_step", ctypes.c_int ),
	( "minus_step", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvSlice, [
	( "start_index", ctypes.c_int ),
	( "end_index", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvScalar, [
	( "val", ( ctypes.c_double * 4 ) ),
])

__freeze_rpythonic_struct( CvMemStoragePos, [
	( "top", ctypes.POINTER(CvMemBlock) ),
	( "free_space", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvGraphEdge, [
	( "flags", ctypes.c_int ),
	( "weight", ctypes.c_float ),
	( "next", ctypes.POINTER(( CvGraphEdge * 2 )) ),
	( "vtx", ctypes.POINTER(( CvGraphVtx * 2 )) ),
])

__freeze_rpythonic_struct( CvGraphVtx, [
	( "flags", ctypes.c_int ),
	( "first", ctypes.POINTER(CvGraphEdge) ),
])

__freeze_rpythonic_struct( CvGraphVtx2D, [
	( "flags", ctypes.c_int ),
	( "first", ctypes.POINTER(CvGraphEdge) ),
	( "ptr", ctypes.POINTER(CvPoint2D32f) ),
])

__freeze_rpythonic_struct( CvGraph, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "h_prev", ctypes.POINTER(CvSeq) ),
	( "h_next", ctypes.POINTER(CvSeq) ),
	( "v_prev", ctypes.POINTER(CvSeq) ),
	( "v_next", ctypes.POINTER(CvSeq) ),
	( "total", ctypes.c_int ),
	( "elem_size", ctypes.c_int ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "delta_elems", ctypes.c_int ),
	( "storage", ctypes.POINTER(CvMemStorage) ),
	( "free_blocks", ctypes.POINTER(CvSeqBlock) ),
	( "first", ctypes.POINTER(CvSeqBlock) ),
	( "free_elems", ctypes.POINTER(CvSetElem) ),
	( "active_count", ctypes.c_int ),
	( "edges", ctypes.POINTER(CvSet) ),
])

__freeze_rpythonic_struct( CvChain, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "h_prev", ctypes.POINTER(CvSeq) ),
	( "h_next", ctypes.POINTER(CvSeq) ),
	( "v_prev", ctypes.POINTER(CvSeq) ),
	( "v_next", ctypes.POINTER(CvSeq) ),
	( "total", ctypes.c_int ),
	( "elem_size", ctypes.c_int ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "delta_elems", ctypes.c_int ),
	( "storage", ctypes.POINTER(CvMemStorage) ),
	( "free_blocks", ctypes.POINTER(CvSeqBlock) ),
	( "first", ctypes.POINTER(CvSeqBlock) ),
	( "origin", CvPoint ),
])

__freeze_rpythonic_struct( CvContour, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "h_prev", ctypes.POINTER(CvSeq) ),
	( "h_next", ctypes.POINTER(CvSeq) ),
	( "v_prev", ctypes.POINTER(CvSeq) ),
	( "v_next", ctypes.POINTER(CvSeq) ),
	( "total", ctypes.c_int ),
	( "elem_size", ctypes.c_int ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "delta_elems", ctypes.c_int ),
	( "storage", ctypes.POINTER(CvMemStorage) ),
	( "free_blocks", ctypes.POINTER(CvSeqBlock) ),
	( "first", ctypes.POINTER(CvSeqBlock) ),
	( "rect", CvRect ),
	( "color", ctypes.c_int ),
	( "reserved", ( ctypes.c_int * 3 ) ),
])

__freeze_rpythonic_struct( CvSeqWriter, [
	( "header_size", ctypes.c_int ),
	( "seq", ctypes.POINTER(CvSeq) ),
	( "block", ctypes.POINTER(CvSeqBlock) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "block_min", ctypes.POINTER(ctypes.c_char) ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
])

__freeze_rpythonic_struct( CvSeqReader, [
	( "header_size", ctypes.c_int ),
	( "seq", ctypes.POINTER(CvSeq) ),
	( "block", ctypes.POINTER(CvSeqBlock) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "block_min", ctypes.POINTER(ctypes.c_char) ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "delta_index", ctypes.c_int ),
	( "prev_elem", ctypes.POINTER(ctypes.c_char) ),
])

__freeze_rpythonic_struct( CvFileStorage, [
])

__freeze_rpythonic_struct( CvAttrList, [
	( "attr", ctypes.POINTER(ctypes.POINTER(ctypes.c_char)) ),
	( "next", ctypes.POINTER(CvAttrList) ),
])

__freeze_rpythonic_struct( CvString, [
	( "C_len", ctypes.c_int ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
])

__freeze_rpythonic_struct( CvStringHashNode, [
	( "hashval", ctypes.c_void_p ),
	( "C_str", CvString ),
	( "next", ctypes.POINTER(CvStringHashNode) ),
])

__freeze_rpythonic_struct( CvGenericHash, [
])

__freeze_rpythonic_struct( CvTypeInfo, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "prev", ctypes.POINTER(CvTypeInfo) ),
	( "next", ctypes.POINTER(CvTypeInfo) ),
	( "type_name", ctypes.POINTER(ctypes.c_char) ),
	( "is_instance", ctypes.CFUNCTYPE(ctypes.c_int, ) ),
	( "release", ctypes.CFUNCTYPE(ctypes.c_void_p, ) ),
	( "read", ctypes.POINTER(ctypes.CFUNCTYPE(ctypes.POINTER(ctypes.c_void_p), ctypes.POINTER(CvFileStorage),ctypes.POINTER(CvFileNode),)) ),
	( "write", ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(CvFileStorage),ctypes.POINTER(ctypes.c_char),ctypes.POINTER(ctypes.c_void_p),CvAttrList,) ),
	( "clone", ctypes.POINTER(ctypes.CFUNCTYPE(ctypes.POINTER(ctypes.c_void_p), )) ),
])

__freeze_rpythonic_struct( CvFileNode, [
	( "tag", ctypes.c_int ),
	( "info", ctypes.POINTER(CvTypeInfo) ),
	( "data", data ),
])

__freeze_rpythonic_struct( CvPluginFuncInfo, [
	( "func_addr", ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p)) ),
	( "default_func_addr", ctypes.POINTER(ctypes.c_void_p) ),
	( "func_names", ctypes.POINTER(ctypes.c_char) ),
	( "search_modules", ctypes.c_int ),
	( "loaded_from", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvModuleInfo, [
	( "next", ctypes.POINTER(CvModuleInfo) ),
	( "name", ctypes.POINTER(ctypes.c_char) ),
	( "version", ctypes.POINTER(ctypes.c_char) ),
	( "func_tab", ctypes.POINTER(CvPluginFuncInfo) ),
])

__freeze_rpythonic_struct( CvNArrayIterator, [
	( "count", ctypes.c_int ),
	( "dims", ctypes.c_int ),
	( "size", CvSize ),
	( "ptr", ctypes.POINTER(( ctypes.c_ubyte * 10 )) ),
	( "stack", ( ctypes.c_int * 32 ) ),
	( "hdr", ctypes.POINTER(( CvMatND * 10 )) ),
])

__freeze_rpythonic_struct( CvGraphScanner, [
	( "vtx", ctypes.POINTER(CvGraphVtx) ),
	( "dst", ctypes.POINTER(CvGraphVtx) ),
	( "edge", ctypes.POINTER(CvGraphEdge) ),
	( "graph", ctypes.POINTER(CvGraph) ),
	( "stack", ctypes.POINTER(CvSeq) ),
	( "index", ctypes.c_int ),
	( "mask", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvFont, [
	( "font_face", ctypes.c_int ),
	( "ascii", ctypes.POINTER(ctypes.c_int) ),
	( "greek", ctypes.POINTER(ctypes.c_int) ),
	( "cyrillic", ctypes.POINTER(ctypes.c_int) ),
	( "hscale", ctypes.c_float ),
	( "vscale", ctypes.c_float ),
	( "shear", ctypes.c_float ),
	( "thickness", ctypes.c_int ),
	( "dx", ctypes.c_float ),
	( "line_type", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvTreeNodeIterator, [
	( "node", ctypes.POINTER(ctypes.c_void_p) ),
	( "level", ctypes.c_int ),
	( "max_level", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvFuncTable, [
	( "fn_2d", ctypes.POINTER(( ctypes.c_void_p * 8 )) ),
])

__freeze_rpythonic_struct( CvBigFuncTable, [
	( "fn_2d", ctypes.POINTER(( ctypes.c_void_p * 800 )) ),
])

__freeze_rpythonic_struct( CvMoments, [
	( "m00", ctypes.c_double ),
	( "m10", ctypes.c_double ),
	( "m01", ctypes.c_double ),
	( "m20", ctypes.c_double ),
	( "m11", ctypes.c_double ),
	( "m02", ctypes.c_double ),
	( "m30", ctypes.c_double ),
	( "m21", ctypes.c_double ),
	( "m12", ctypes.c_double ),
	( "m03", ctypes.c_double ),
	( "mu20", ctypes.c_double ),
	( "mu11", ctypes.c_double ),
	( "mu02", ctypes.c_double ),
	( "mu30", ctypes.c_double ),
	( "mu21", ctypes.c_double ),
	( "mu12", ctypes.c_double ),
	( "mu03", ctypes.c_double ),
	( "inv_sqrt_m00", ctypes.c_double ),
])

__freeze_rpythonic_struct( CvHuMoments, [
	( "hu1", ctypes.c_double ),
	( "hu2", ctypes.c_double ),
	( "hu3", ctypes.c_double ),
	( "hu4", ctypes.c_double ),
	( "hu5", ctypes.c_double ),
	( "hu6", ctypes.c_double ),
	( "hu7", ctypes.c_double ),
])

__freeze_rpythonic_struct( CvConnectedComp, [
	( "area", ctypes.c_double ),
	( "value", CvScalar ),
	( "rect", CvRect ),
	( "contour", ctypes.POINTER(CvSeq) ),
])

__freeze_rpythonic_struct( _CvContourScanner, [
])

__freeze_rpythonic_struct( CvChainPtReader, [
	( "header_size", ctypes.c_int ),
	( "seq", ctypes.POINTER(CvSeq) ),
	( "block", ctypes.POINTER(CvSeqBlock) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "block_min", ctypes.POINTER(ctypes.c_char) ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "delta_index", ctypes.c_int ),
	( "prev_elem", ctypes.POINTER(ctypes.c_char) ),
	( "code", ctypes.c_char ),
	( "pt", CvPoint ),
	( "deltas", ( ctypes.c_char * 8 ) ),
])

__freeze_rpythonic_struct( CvContourTree, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "h_prev", ctypes.POINTER(CvSeq) ),
	( "h_next", ctypes.POINTER(CvSeq) ),
	( "v_prev", ctypes.POINTER(CvSeq) ),
	( "v_next", ctypes.POINTER(CvSeq) ),
	( "total", ctypes.c_int ),
	( "elem_size", ctypes.c_int ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "delta_elems", ctypes.c_int ),
	( "storage", ctypes.POINTER(CvMemStorage) ),
	( "free_blocks", ctypes.POINTER(CvSeqBlock) ),
	( "first", ctypes.POINTER(CvSeqBlock) ),
	( "p1", CvPoint ),
	( "p2", CvPoint ),
])

__freeze_rpythonic_struct( CvConvexityDefect, [
	( "start", ctypes.POINTER(CvPoint) ),
	( "end", ctypes.POINTER(CvPoint) ),
	( "depth_point", ctypes.POINTER(CvPoint) ),
	( "depth", ctypes.c_float ),
])

__freeze_rpythonic_struct( CvSubdiv2DPoint, [
	( "flags", ctypes.c_int ),
	( "first", ctypes.c_size_t ),
	( "pt", CvPoint2D32f ),
	( "C_id", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvQuadEdge2D, [
	( "flags", ctypes.c_int ),
	( "pt", ctypes.POINTER(( CvSubdiv2DPoint * 4 )) ),
	( "next", ( ctypes.c_size_t * 4 ) ),
])

__freeze_rpythonic_struct( CvSubdiv2D, [
	( "flags", ctypes.c_int ),
	( "header_size", ctypes.c_int ),
	( "h_prev", ctypes.POINTER(CvSeq) ),
	( "h_next", ctypes.POINTER(CvSeq) ),
	( "v_prev", ctypes.POINTER(CvSeq) ),
	( "v_next", ctypes.POINTER(CvSeq) ),
	( "total", ctypes.c_int ),
	( "elem_size", ctypes.c_int ),
	( "block_max", ctypes.POINTER(ctypes.c_char) ),
	( "ptr", ctypes.POINTER(ctypes.c_char) ),
	( "delta_elems", ctypes.c_int ),
	( "storage", ctypes.POINTER(CvMemStorage) ),
	( "free_blocks", ctypes.POINTER(CvSeqBlock) ),
	( "first", ctypes.POINTER(CvSeqBlock) ),
	( "free_elems", ctypes.POINTER(CvSetElem) ),
	( "active_count", ctypes.c_int ),
	( "edges", ctypes.POINTER(CvSet) ),
	( "quad_edges", ctypes.c_int ),
	( "is_geometry_valid", ctypes.c_int ),
	( "recent_edge", ctypes.c_size_t ),
	( "topleft", CvPoint2D32f ),
	( "bottomright", CvPoint2D32f ),
])

__freeze_rpythonic_struct( CvMatrix3, [
	( "m", ( ctypes.c_float * 3 ) ),
])

__freeze_rpythonic_struct( CvKalman, [
	( "MP", ctypes.c_int ),
	( "DP", ctypes.c_int ),
	( "CP", ctypes.c_int ),
	( "PosterState", ctypes.POINTER(ctypes.c_float) ),
	( "PriorState", ctypes.POINTER(ctypes.c_float) ),
	( "DynamMatr", ctypes.POINTER(ctypes.c_float) ),
	( "MeasurementMatr", ctypes.POINTER(ctypes.c_float) ),
	( "MNCovariance", ctypes.POINTER(ctypes.c_float) ),
	( "PNCovariance", ctypes.POINTER(ctypes.c_float) ),
	( "KalmGainMatr", ctypes.POINTER(ctypes.c_float) ),
	( "PriorErrorCovariance", ctypes.POINTER(ctypes.c_float) ),
	( "PosterErrorCovariance", ctypes.POINTER(ctypes.c_float) ),
	( "Temp1", ctypes.POINTER(ctypes.c_float) ),
	( "Temp2", ctypes.POINTER(ctypes.c_float) ),
	( "state_pre", ctypes.POINTER(CvMat) ),
	( "state_post", ctypes.POINTER(CvMat) ),
	( "transition_matrix", ctypes.POINTER(CvMat) ),
	( "control_matrix", ctypes.POINTER(CvMat) ),
	( "measurement_matrix", ctypes.POINTER(CvMat) ),
	( "process_noise_cov", ctypes.POINTER(CvMat) ),
	( "measurement_noise_cov", ctypes.POINTER(CvMat) ),
	( "error_cov_pre", ctypes.POINTER(CvMat) ),
	( "gain", ctypes.POINTER(CvMat) ),
	( "error_cov_post", ctypes.POINTER(CvMat) ),
	( "temp1", ctypes.POINTER(CvMat) ),
	( "temp2", ctypes.POINTER(CvMat) ),
	( "temp3", ctypes.POINTER(CvMat) ),
	( "temp4", ctypes.POINTER(CvMat) ),
	( "temp5", ctypes.POINTER(CvMat) ),
])

__freeze_rpythonic_struct( rect, [
	( "r", ( CvRect * 3 ) ),
	( "weight", ( ctypes.c_float * 3 ) ),
])

__freeze_rpythonic_struct( CvHaarFeature, [
	( "tilted", ctypes.c_int ),
	( "rect", ( rect * 3 ) ),
])

__freeze_rpythonic_struct( CvHaarClassifier, [
	( "count", ctypes.c_int ),
	( "haar_feature", ctypes.POINTER(CvHaarFeature) ),
	( "threshold", ctypes.POINTER(ctypes.c_float) ),
	( "left", ctypes.POINTER(ctypes.c_int) ),
	( "right", ctypes.POINTER(ctypes.c_int) ),
	( "alpha", ctypes.POINTER(ctypes.c_float) ),
])

__freeze_rpythonic_struct( CvHaarStageClassifier, [
	( "count", ctypes.c_int ),
	( "threshold", ctypes.c_float ),
	( "classifier", ctypes.POINTER(CvHaarClassifier) ),
	( "next", ctypes.c_int ),
	( "child", ctypes.c_int ),
	( "parent", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvHidHaarClassifierCascade, [
])

__freeze_rpythonic_struct( CvHaarClassifierCascade, [
	( "flags", ctypes.c_int ),
	( "count", ctypes.c_int ),
	( "orig_window_size", CvSize ),
	( "real_window_size", CvSize ),
	( "scale", ctypes.c_double ),
	( "stage_classifier", ctypes.POINTER(CvHaarStageClassifier) ),
	( "hid_cascade", ctypes.POINTER(CvHidHaarClassifierCascade) ),
])

__freeze_rpythonic_struct( CvAvgComp, [
	( "rect", CvRect ),
	( "neighbors", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvFeatureTree, [
])

__freeze_rpythonic_struct( CvLSH, [
])

__freeze_rpythonic_struct( CvLSHOperations, [
])

__freeze_rpythonic_struct( CvSURFPoint, [
	( "pt", CvPoint2D32f ),
	( "laplacian", ctypes.c_int ),
	( "size", ctypes.c_int ),
	( "dir", ctypes.c_float ),
	( "hessian", ctypes.c_float ),
])

__freeze_rpythonic_struct( CvSURFParams, [
	( "extended", ctypes.c_int ),
	( "hessianThreshold", ctypes.c_double ),
	( "nOctaves", ctypes.c_int ),
	( "nOctaveLayers", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvMSERParams, [
	( "delta", ctypes.c_int ),
	( "maxArea", ctypes.c_int ),
	( "minArea", ctypes.c_int ),
	( "maxVariation", ctypes.c_float ),
	( "minDiversity", ctypes.c_float ),
	( "maxEvolution", ctypes.c_int ),
	( "areaThreshold", ctypes.c_double ),
	( "minMargin", ctypes.c_double ),
	( "edgeBlurSize", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvStarKeypoint, [
	( "pt", CvPoint ),
	( "size", ctypes.c_int ),
	( "response", ctypes.c_float ),
])

__freeze_rpythonic_struct( CvStarDetectorParams, [
	( "maxSize", ctypes.c_int ),
	( "responseThreshold", ctypes.c_int ),
	( "lineThresholdProjected", ctypes.c_int ),
	( "lineThresholdBinarized", ctypes.c_int ),
	( "suppressNonmaxSize", ctypes.c_int ),
])

__freeze_rpythonic_struct( CvPOSITObject, [
])

__freeze_rpythonic_struct( CvStereoBMState, [
	( "preFilterType", ctypes.c_int ),
	( "preFilterSize", ctypes.c_int ),
	( "preFilterCap", ctypes.c_int ),
	( "SADWindowSize", ctypes.c_int ),
	( "minDisparity", ctypes.c_int ),
	( "numberOfDisparities", ctypes.c_int ),
	( "textureThreshold", ctypes.c_int ),
	( "uniquenessRatio", ctypes.c_int ),
	( "speckleWindowSize", ctypes.c_int ),
	( "speckleRange", ctypes.c_int ),
	( "trySmallerWindows", ctypes.c_int ),
	( "roi1", CvRect ),
	( "roi2", CvRect ),
	( "disp12MaxDiff", ctypes.c_int ),
	( "preFilteredImg0", ctypes.POINTER(CvMat) ),
	( "preFilteredImg1", ctypes.POINTER(CvMat) ),
	( "slidingSumBuf", ctypes.POINTER(CvMat) ),
	( "cost", ctypes.POINTER(CvMat) ),
	( "disp", ctypes.POINTER(CvMat) ),
])

__freeze_rpythonic_struct( CvStereoGCState, [
	( "Ithreshold", ctypes.c_int ),
	( "interactionRadius", ctypes.c_int ),
	( "K", ctypes.c_float ),
	( "C_lambda", ctypes.c_float ),
	( "lambda1", ctypes.c_float ),
	( "lambda2", ctypes.c_float ),
	( "occlusionCost", ctypes.c_int ),
	( "minDisparity", ctypes.c_int ),
	( "numberOfDisparities", ctypes.c_int ),
	( "maxIters", ctypes.c_int ),
	( "left", ctypes.POINTER(CvMat) ),
	( "right", ctypes.POINTER(CvMat) ),
	( "dispLeft", ctypes.POINTER(CvMat) ),
	( "dispRight", ctypes.POINTER(CvMat) ),
	( "ptrLeft", ctypes.POINTER(CvMat) ),
	( "ptrRight", ctypes.POINTER(CvMat) ),
	( "vtxBuf", ctypes.POINTER(CvMat) ),
	( "edgeBuf", ctypes.POINTER(CvMat) ),
])

__freeze_rpythonic_struct( CvRandState, [
	( "state", ctypes.c_uint64 ),
	( "disttype", ctypes.c_int ),
	( "param", ( CvScalar * 2 ) ),
])

__freeze_rpythonic_struct( _CvPixelPosition8u, [
	( "currline", ctypes.POINTER(ctypes.c_ubyte) ),
	( "topline", ctypes.POINTER(ctypes.c_ubyte) ),
	( "bottomline", ctypes.POINTER(ctypes.c_ubyte) ),
	( "x", ctypes.c_int ),
	( "width", ctypes.c_int ),
	( "height", ctypes.c_int ),
	( "step", ctypes.c_int ),
	( "step_arr", ( ctypes.c_int * 3 ) ),
])

__freeze_rpythonic_struct( _CvPixelPosition8s, [
	( "currline", ctypes.POINTER(ctypes.c_char) ),
	( "topline", ctypes.POINTER(ctypes.c_char) ),
	( "bottomline", ctypes.POINTER(ctypes.c_char) ),
	( "x", ctypes.c_int ),
	( "width", ctypes.c_int ),
	( "height", ctypes.c_int ),
	( "step", ctypes.c_int ),
	( "step_arr", ( ctypes.c_int * 3 ) ),
])

__freeze_rpythonic_struct( _CvPixelPosition32f, [
	( "currline", ctypes.POINTER(ctypes.c_float) ),
	( "topline", ctypes.POINTER(ctypes.c_float) ),
	( "bottomline", ctypes.POINTER(ctypes.c_float) ),
	( "x", ctypes.c_int ),
	( "width", ctypes.c_int ),
	( "height", ctypes.c_int ),
	( "step", ctypes.c_int ),
	( "step_arr", ( ctypes.c_int * 3 ) ),
])

## wrapper functions ##
cvNormalizeHist = _rpythonic_function_(		"cvNormalizeHist", ctypes.c_void_p, [
	("hist",		ctypes.POINTER(CvHistogram)),
	("factor",		ctypes.c_double),] )

cvCopyHist = _rpythonic_function_(		"cvCopyHist", ctypes.c_void_p, [
	("src",		ctypes.POINTER(CvHistogram)),
	("dst",		ctypes.POINTER(ctypes.POINTER(CvHistogram))),] )

cvThreshHist = _rpythonic_function_(		"cvThreshHist", ctypes.c_void_p, [
	("hist",		ctypes.POINTER(CvHistogram)),
	("threshold",		ctypes.c_double),] )

cvCompareHist = _rpythonic_function_(		"cvCompareHist", ctypes.c_double, [
	("hist1",		ctypes.POINTER(CvHistogram)),
	("hist2",		ctypes.POINTER(CvHistogram)),
	("method",		ctypes.c_int),] )

cvCalcBayesianProb = _rpythonic_function_(		"cvCalcBayesianProb", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.POINTER(CvHistogram))),
	("number",		ctypes.c_int),
	("dst",		ctypes.POINTER(ctypes.POINTER(CvHistogram))),] )

cvCalcArrHist = _rpythonic_function_(		"cvCalcArrHist", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("hist",		ctypes.POINTER(CvHistogram)),
	("accumulate",		ctypes.c_int),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCreateHist = _rpythonic_function_(		"cvCreateHist", ctypes.POINTER(CvHistogram), [
	("dims",		ctypes.c_int),
	("sizes",		ctypes.POINTER(ctypes.c_int)),
	("C_type",		ctypes.c_int),
	("ranges",		ctypes.POINTER(ctypes.POINTER(ctypes.c_float))),
	("uniform",		ctypes.c_int),] )

cvSetHistBinRanges = _rpythonic_function_(		"cvSetHistBinRanges", ctypes.c_void_p, [
	("hist",		ctypes.POINTER(CvHistogram)),
	("ranges",		ctypes.POINTER(ctypes.POINTER(ctypes.c_float))),
	("uniform",		ctypes.c_int),] )

cvMakeHistHeaderForArray = _rpythonic_function_(		"cvMakeHistHeaderForArray", ctypes.POINTER(CvHistogram), [
	("dims",		ctypes.c_int),
	("sizes",		ctypes.POINTER(ctypes.c_int)),
	("hist",		ctypes.POINTER(CvHistogram)),
	("data",		ctypes.POINTER(ctypes.c_float)),
	("ranges",		ctypes.POINTER(ctypes.POINTER(ctypes.c_float))),
	("uniform",		ctypes.c_int),] )

cvReleaseHist = _rpythonic_function_(		"cvReleaseHist", ctypes.c_void_p, [
	("hist",		ctypes.POINTER(ctypes.POINTER(CvHistogram))),] )

cvClearHist = _rpythonic_function_(		"cvClearHist", ctypes.c_void_p, [
	("hist",		ctypes.POINTER(CvHistogram)),] )

cvGetMinMaxHistValue = _rpythonic_function_(		"cvGetMinMaxHistValue", ctypes.c_void_p, [
	("hist",		ctypes.POINTER(CvHistogram)),
	("min_value",		ctypes.POINTER(ctypes.c_float)),
	("max_value",		ctypes.POINTER(ctypes.c_float)),
	("min_idx",		ctypes.POINTER(ctypes.c_int)),
	("max_idx",		ctypes.POINTER(ctypes.c_int)),] )

cvCheckContourConvexity = _rpythonic_function_(		"cvCheckContourConvexity", ctypes.c_int, [("contour",		ctypes.c_void_p)] )

cvConvexityDefects = _rpythonic_function_(		"cvConvexityDefects", ctypes.POINTER(CvSeq), [
	("contour",		ctypes.POINTER(ctypes.c_void_p)),
	("convexhull",		ctypes.POINTER(ctypes.c_void_p)),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvFitEllipse2 = _rpythonic_function_(		"cvFitEllipse2", CvBox2D, [("points",		ctypes.c_void_p)] )

cvBoxPoints = _rpythonic_function_(		"cvBoxPoints", ctypes.c_void_p, [
	("box",		CvBox2D),
	("pt",		( CvPoint2D32f * 4 )),] )

cvMaxRect = _rpythonic_function_(		"cvMaxRect", CvRect, [
	("rect1",		ctypes.POINTER(CvRect)),
	("rect2",		ctypes.POINTER(CvRect)),] )

cvPointSeqFromMat = _rpythonic_function_(		"cvPointSeqFromMat", ctypes.POINTER(CvSeq), [
	("seq_kind",		ctypes.c_int),
	("mat",		ctypes.POINTER(ctypes.c_void_p)),
	("contour_header",		ctypes.POINTER(CvContour)),
	("block",		ctypes.POINTER(CvSeqBlock)),] )

cvPointPolygonTest = _rpythonic_function_(		"cvPointPolygonTest", ctypes.c_double, [
	("contour",		ctypes.POINTER(ctypes.c_void_p)),
	("pt",		CvPoint2D32f),
	("measure_dist",		ctypes.c_int),] )

cvMinAreaRect2 = _rpythonic_function_(		"cvMinAreaRect2", CvBox2D, [
	("points",		ctypes.POINTER(ctypes.c_void_p)),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvMinEnclosingCircle = _rpythonic_function_(		"cvMinEnclosingCircle", ctypes.c_int, [
	("points",		ctypes.POINTER(ctypes.c_void_p)),
	("center",		ctypes.POINTER(CvPoint2D32f)),
	("radius",		ctypes.POINTER(ctypes.c_float)),] )

cvMatchShapes = _rpythonic_function_(		"cvMatchShapes", ctypes.c_double, [
	("object1",		ctypes.POINTER(ctypes.c_void_p)),
	("object2",		ctypes.POINTER(ctypes.c_void_p)),
	("method",		ctypes.c_int),
	("parameter",		ctypes.c_double),] )

cvCreateContourTree = _rpythonic_function_(		"cvCreateContourTree", ctypes.POINTER(CvContourTree), [
	("contour",		ctypes.POINTER(CvSeq)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("threshold",		ctypes.c_double),] )

cvContourFromContourTree = _rpythonic_function_(		"cvContourFromContourTree", ctypes.POINTER(CvSeq), [
	("tree",		ctypes.POINTER(CvContourTree)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("criteria",		CvTermCriteria),] )

cvMatchContourTrees = _rpythonic_function_(		"cvMatchContourTrees", ctypes.c_double, [
	("tree1",		ctypes.POINTER(CvContourTree)),
	("tree2",		ctypes.POINTER(CvContourTree)),
	("method",		ctypes.c_int),
	("threshold",		ctypes.c_double),] )

cvConvexHull2 = _rpythonic_function_(		"cvConvexHull2", ctypes.POINTER(CvSeq), [
	("input",		ctypes.POINTER(ctypes.c_void_p)),
	("hull_storage",		ctypes.POINTER(ctypes.c_void_p)),
	("orientation",		ctypes.c_int),
	("return_points",		ctypes.c_int),] )

cvApproxPoly = _rpythonic_function_(		"cvApproxPoly", ctypes.POINTER(CvSeq), [
	("src_seq",		ctypes.POINTER(ctypes.c_void_p)),
	("header_size",		ctypes.c_int),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("method",		ctypes.c_int),
	("parameter",		ctypes.c_double),
	("parameter2",		ctypes.c_int),] )

cvArcLength = _rpythonic_function_(		"cvArcLength", ctypes.c_double, [
	("curve",		ctypes.POINTER(ctypes.c_void_p)),
	("slice",		CvSlice),
	("is_closed",		ctypes.c_int),] )

cvBoundingRect = _rpythonic_function_(		"cvBoundingRect", CvRect, [
	("points",		ctypes.POINTER(ctypes.c_void_p)),
	("update",		ctypes.c_int),] )

cvContourArea = _rpythonic_function_(		"cvContourArea", ctypes.c_double, [
	("contour",		ctypes.POINTER(ctypes.c_void_p)),
	("slice",		CvSlice),
	("oriented",		ctypes.c_int),] )

cvRunningAvg = _rpythonic_function_(		"cvRunningAvg", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("acc",		ctypes.POINTER(ctypes.c_void_p)),
	("alpha",		ctypes.c_double),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCamShift = _rpythonic_function_(		"cvCamShift", ctypes.c_int, [
	("prob_image",		ctypes.POINTER(ctypes.c_void_p)),
	("window",		CvRect),
	("criteria",		CvTermCriteria),
	("comp",		ctypes.POINTER(CvConnectedComp)),
	("box",		ctypes.POINTER(CvBox2D)),] )

cvMeanShift = _rpythonic_function_(		"cvMeanShift", ctypes.c_int, [
	("prob_image",		ctypes.POINTER(ctypes.c_void_p)),
	("window",		CvRect),
	("criteria",		CvTermCriteria),
	("comp",		ctypes.POINTER(CvConnectedComp)),] )

cvCreateKalman = _rpythonic_function_(		"cvCreateKalman", ctypes.POINTER(CvKalman), [
	("dynam_params",		ctypes.c_int),
	("measure_params",		ctypes.c_int),
	("control_params",		ctypes.c_int),] )

cvReleaseKalman = _rpythonic_function_(		"cvReleaseKalman", ctypes.c_void_p, [
	("kalman",		ctypes.POINTER(ctypes.POINTER(CvKalman))),] )

cvKalmanPredict = _rpythonic_function_(		"cvKalmanPredict", ctypes.POINTER(CvMat), [
	("kalman",		ctypes.POINTER(CvKalman)),
	("control",		ctypes.POINTER(CvMat)),] )

cvKalmanCorrect = _rpythonic_function_(		"cvKalmanCorrect", ctypes.POINTER(CvMat), [
	("kalman",		ctypes.POINTER(CvKalman)),
	("measurement",		ctypes.POINTER(CvMat)),] )

cvInitSubdivDelaunay2D = _rpythonic_function_(		"cvInitSubdivDelaunay2D", ctypes.c_void_p, [
	("subdiv",		ctypes.POINTER(CvSubdiv2D)),
	("rect",		CvRect),] )

cvCreateSubdiv2D = _rpythonic_function_(		"cvCreateSubdiv2D", ctypes.POINTER(CvSubdiv2D), [
	("subdiv_type",		ctypes.c_int),
	("header_size",		ctypes.c_int),
	("vtx_size",		ctypes.c_int),
	("quadedge_size",		ctypes.c_int),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvSubdivDelaunay2DInsert = _rpythonic_function_(		"cvSubdivDelaunay2DInsert", ctypes.POINTER(CvSubdiv2DPoint), [
	("subdiv",		ctypes.POINTER(CvSubdiv2D)),
	("pt",		CvPoint2D32f),] )

cvSubdiv2DLocate = _rpythonic_function_(		"cvSubdiv2DLocate", ctypes.c_int, [
	("subdiv",		ctypes.POINTER(CvSubdiv2D)),
	("pt",		CvPoint2D32f),
	("edge",		ctypes.POINTER(ctypes.c_size_t)),
	("vertex",		ctypes.POINTER(ctypes.POINTER(CvSubdiv2DPoint))),] )

cvCalcSubdivVoronoi2D = _rpythonic_function_(		"cvCalcSubdivVoronoi2D", ctypes.c_void_p, [
	("subdiv",		ctypes.POINTER(CvSubdiv2D)),] )

cvClearSubdivVoronoi2D = _rpythonic_function_(		"cvClearSubdivVoronoi2D", ctypes.c_void_p, [
	("subdiv",		ctypes.POINTER(CvSubdiv2D)),] )

cvFindNearestPoint2D = _rpythonic_function_(		"cvFindNearestPoint2D", ctypes.POINTER(CvSubdiv2DPoint), [
	("subdiv",		ctypes.POINTER(CvSubdiv2D)),
	("pt",		CvPoint2D32f),] )

cvCalcGlobalOrientation = _rpythonic_function_(		"cvCalcGlobalOrientation", ctypes.c_double, [
	("orientation",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),
	("mhi",		ctypes.POINTER(ctypes.c_void_p)),
	("timestamp",		ctypes.c_double),
	("duration",		ctypes.c_double),] )

cvSegmentMotion = _rpythonic_function_(		"cvSegmentMotion", ctypes.POINTER(CvSeq), [
	("mhi",		ctypes.POINTER(ctypes.c_void_p)),
	("seg_mask",		ctypes.POINTER(ctypes.c_void_p)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("timestamp",		ctypes.c_double),
	("seg_thresh",		ctypes.c_double),] )

cvSquareAcc = _rpythonic_function_(		"cvSquareAcc", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("sqsum",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvAcc = _rpythonic_function_(		"cvAcc", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("sum",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMultiplyAcc = _rpythonic_function_(		"cvMultiplyAcc", ctypes.c_void_p, [
	("image1",		ctypes.POINTER(ctypes.c_void_p)),
	("image2",		ctypes.POINTER(ctypes.c_void_p)),
	("acc",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvEstimateRigidTransform = _rpythonic_function_(		"cvEstimateRigidTransform", ctypes.c_int, [
	("A",		ctypes.POINTER(ctypes.c_void_p)),
	("B",		ctypes.POINTER(ctypes.c_void_p)),
	("M",		ctypes.POINTER(CvMat)),
	("full_affine",		ctypes.c_int),] )

cvCalcOpticalFlowFarneback = _rpythonic_function_(		"cvCalcOpticalFlowFarneback", ctypes.c_void_p, [
	("prev",		ctypes.POINTER(ctypes.c_void_p)),
	("next",		ctypes.POINTER(ctypes.c_void_p)),
	("flow",		ctypes.POINTER(ctypes.c_void_p)),
	("pyr_scale",		ctypes.c_double),
	("levels",		ctypes.c_int),
	("winsize",		ctypes.c_int),
	("iterations",		ctypes.c_int),
	("poly_n",		ctypes.c_int),
	("poly_sigma",		ctypes.c_double),
	("flags",		ctypes.c_int),] )

cvUpdateMotionHistory = _rpythonic_function_(		"cvUpdateMotionHistory", ctypes.c_void_p, [
	("silhouette",		ctypes.POINTER(ctypes.c_void_p)),
	("mhi",		ctypes.POINTER(ctypes.c_void_p)),
	("timestamp",		ctypes.c_double),
	("duration",		ctypes.c_double),] )

cvCalcMotionGradient = _rpythonic_function_(		"cvCalcMotionGradient", ctypes.c_void_p, [
	("mhi",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),
	("orientation",		ctypes.POINTER(ctypes.c_void_p)),
	("delta1",		ctypes.c_double),
	("delta2",		ctypes.c_double),
	("aperture_size",		ctypes.c_int),] )

cvCalcOpticalFlowHS = _rpythonic_function_(		"cvCalcOpticalFlowHS", ctypes.c_void_p, [
	("prev",		ctypes.POINTER(ctypes.c_void_p)),
	("curr",		ctypes.POINTER(ctypes.c_void_p)),
	("use_previous",		ctypes.c_int),
	("velx",		ctypes.POINTER(ctypes.c_void_p)),
	("vely",		ctypes.POINTER(ctypes.c_void_p)),
	("C_lambda",		ctypes.c_double),
	("criteria",		CvTermCriteria),] )

cvCalcOpticalFlowPyrLK = _rpythonic_function_(		"cvCalcOpticalFlowPyrLK", ctypes.c_void_p, [
	("prev",		ctypes.POINTER(ctypes.c_void_p)),
	("curr",		ctypes.POINTER(ctypes.c_void_p)),
	("prev_pyr",		ctypes.POINTER(ctypes.c_void_p)),
	("curr_pyr",		ctypes.POINTER(ctypes.c_void_p)),
	("prev_features",		ctypes.POINTER(CvPoint2D32f)),
	("curr_features",		ctypes.POINTER(CvPoint2D32f)),
	("count",		ctypes.c_int),
	("win_size",		CvSize),
	("level",		ctypes.c_int),
	("status",		ctypes.POINTER(ctypes.c_char)),
	("track_error",		ctypes.POINTER(ctypes.c_float)),
	("criteria",		CvTermCriteria),
	("flags",		ctypes.c_int),] )

cvCalcAffineFlowPyrLK = _rpythonic_function_(		"cvCalcAffineFlowPyrLK", ctypes.c_void_p, [
	("prev",		ctypes.POINTER(ctypes.c_void_p)),
	("curr",		ctypes.POINTER(ctypes.c_void_p)),
	("prev_pyr",		ctypes.POINTER(ctypes.c_void_p)),
	("curr_pyr",		ctypes.POINTER(ctypes.c_void_p)),
	("prev_features",		ctypes.POINTER(CvPoint2D32f)),
	("curr_features",		ctypes.POINTER(CvPoint2D32f)),
	("matrices",		ctypes.POINTER(ctypes.c_float)),
	("count",		ctypes.c_int),
	("win_size",		CvSize),
	("level",		ctypes.c_int),
	("status",		ctypes.POINTER(ctypes.c_char)),
	("track_error",		ctypes.POINTER(ctypes.c_float)),
	("criteria",		CvTermCriteria),
	("flags",		ctypes.c_int),] )

cvSubstituteContour = _rpythonic_function_(		"cvSubstituteContour", ctypes.c_void_p, [
	("scanner",		ctypes.POINTER(_CvContourScanner)),
	("new_contour",		ctypes.POINTER(CvSeq)),] )

cvEndFindContours = _rpythonic_function_(		"cvEndFindContours", ctypes.POINTER(CvSeq), [
	("scanner",		ctypes.POINTER(ctypes.POINTER(_CvContourScanner))),] )

cvApproxChains = _rpythonic_function_(		"cvApproxChains", ctypes.POINTER(CvSeq), [
	("src_seq",		ctypes.POINTER(CvSeq)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("method",		ctypes.c_int),
	("parameter",		ctypes.c_double),
	("minimal_perimeter",		ctypes.c_int),
	("recursive",		ctypes.c_int),] )

cvStartReadChainPoints = _rpythonic_function_(		"cvStartReadChainPoints", ctypes.c_void_p, [
	("chain",		ctypes.POINTER(CvChain)),
	("reader",		ctypes.POINTER(CvChainPtReader)),] )

cvReadChainPoint = _rpythonic_function_(		"cvReadChainPoint", CvPoint, [
	("reader",		ctypes.POINTER(CvChainPtReader)),] )

cvCalcOpticalFlowLK = _rpythonic_function_(		"cvCalcOpticalFlowLK", ctypes.c_void_p, [
	("prev",		ctypes.POINTER(ctypes.c_void_p)),
	("curr",		ctypes.POINTER(ctypes.c_void_p)),
	("win_size",		CvSize),
	("velx",		ctypes.POINTER(ctypes.c_void_p)),
	("vely",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCalcOpticalFlowBM = _rpythonic_function_(		"cvCalcOpticalFlowBM", ctypes.c_void_p, [
	("prev",		ctypes.POINTER(ctypes.c_void_p)),
	("curr",		ctypes.POINTER(ctypes.c_void_p)),
	("block_size",		CvSize),
	("shift_size",		CvSize),
	("max_range",		CvSize),
	("use_previous",		ctypes.c_int),
	("velx",		ctypes.POINTER(ctypes.c_void_p)),
	("vely",		ctypes.POINTER(ctypes.c_void_p)),] )

CvDistanceFunction = _rpythonic_function_(		"CvDistanceFunction", ctypes.c_float, [
	("a",		ctypes.POINTER(ctypes.c_float)),
	("b",		ctypes.POINTER(ctypes.c_float)),
	("user_param",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCopyMakeBorder = _rpythonic_function_(		"cvCopyMakeBorder", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("offset",		CvPoint),
	("bordertype",		ctypes.c_int),
	("value",		CvScalar),] )

cvSmooth = _rpythonic_function_(		"cvSmooth", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("smoothtype",		ctypes.c_int),
	("size1",		ctypes.c_int),
	("size2",		ctypes.c_int),
	("sigma1",		ctypes.c_double),
	("sigma2",		ctypes.c_double),] )

cvFilter2D = _rpythonic_function_(		"cvFilter2D", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("kernel",		ctypes.POINTER(CvMat)),
	("anchor",		CvPoint),] )

cvIntegral = _rpythonic_function_(		"cvIntegral", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("sum",		ctypes.POINTER(ctypes.c_void_p)),
	("sqsum",		ctypes.POINTER(ctypes.c_void_p)),
	("tilted_sum",		ctypes.POINTER(ctypes.c_void_p)),] )

cvPyrDown = _rpythonic_function_(		"cvPyrDown", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("filter",		ctypes.c_int),] )

cvCreatePyramid = _rpythonic_function_(		"cvCreatePyramid", ctypes.POINTER(ctypes.POINTER(CvMat)), [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("extra_layers",		ctypes.c_int),
	("rate",		ctypes.c_double),
	("layer_sizes",		ctypes.POINTER(CvSize)),
	("bufarr",		ctypes.POINTER(ctypes.c_void_p)),
	("calc",		ctypes.c_int),
	("filter",		ctypes.c_int),] )

cvPyrUp = _rpythonic_function_(		"cvPyrUp", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("filter",		ctypes.c_int),] )

cvReleasePyramid = _rpythonic_function_(		"cvReleasePyramid", ctypes.c_void_p, [
	("pyramid",		ctypes.POINTER(ctypes.POINTER(ctypes.POINTER(CvMat)))),
	("extra_layers",		ctypes.c_int),] )

cvPyrSegmentation = _rpythonic_function_(		"cvPyrSegmentation", ctypes.c_void_p, [
	("src",		ctypes.POINTER(_IplImage)),
	("dst",		ctypes.POINTER(_IplImage)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("comp",		ctypes.POINTER(ctypes.POINTER(CvSeq))),
	("level",		ctypes.c_int),
	("threshold1",		ctypes.c_double),
	("threshold2",		ctypes.c_double),] )

cvPyrMeanShiftFiltering = _rpythonic_function_(		"cvPyrMeanShiftFiltering", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("sp",		ctypes.c_double),
	("sr",		ctypes.c_double),
	("max_level",		ctypes.c_int),
	("termcrit",		CvTermCriteria),] )

cvWatershed = _rpythonic_function_(		"cvWatershed", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("markers",		ctypes.POINTER(ctypes.c_void_p)),] )

cvInpaint = _rpythonic_function_(		"cvInpaint", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("inpaint_mask",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("inpaintRange",		ctypes.c_double),
	("flags",		ctypes.c_int),] )

cvSobel = _rpythonic_function_(		"cvSobel", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("xorder",		ctypes.c_int),
	("yorder",		ctypes.c_int),
	("aperture_size",		ctypes.c_int),] )

cvCvtColor = _rpythonic_function_(		"cvCvtColor", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("code",		ctypes.c_int),] )

cvLaplace = _rpythonic_function_(		"cvLaplace", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("aperture_size",		ctypes.c_int),] )

cvResize = _rpythonic_function_(		"cvResize", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("interpolation",		ctypes.c_int),] )

cvWarpAffine = _rpythonic_function_(		"cvWarpAffine", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("map_matrix",		ctypes.POINTER(CvMat)),
	("flags",		ctypes.c_int),
	("fillval",		CvScalar),] )

cvGetAffineTransform = _rpythonic_function_(		"cvGetAffineTransform", ctypes.POINTER(CvMat), [
	("src",		ctypes.POINTER(CvPoint2D32f)),
	("dst",		ctypes.POINTER(CvPoint2D32f)),
	("map_matrix",		ctypes.POINTER(CvMat)),] )

cv2DRotationMatrix = _rpythonic_function_(		"cv2DRotationMatrix", ctypes.POINTER(CvMat), [
	("center",		CvPoint2D32f),
	("angle",		ctypes.c_double),
	("scale",		ctypes.c_double),
	("map_matrix",		ctypes.POINTER(CvMat)),] )

cvWarpPerspective = _rpythonic_function_(		"cvWarpPerspective", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("map_matrix",		ctypes.POINTER(CvMat)),
	("flags",		ctypes.c_int),
	("fillval",		CvScalar),] )

cvGetPerspectiveTransform = _rpythonic_function_(		"cvGetPerspectiveTransform", ctypes.POINTER(CvMat), [
	("src",		ctypes.POINTER(CvPoint2D32f)),
	("dst",		ctypes.POINTER(CvPoint2D32f)),
	("map_matrix",		ctypes.POINTER(CvMat)),] )

cvRemap = _rpythonic_function_(		"cvRemap", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mapx",		ctypes.POINTER(ctypes.c_void_p)),
	("mapy",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),
	("fillval",		CvScalar),] )

cvLinearPolar = _rpythonic_function_(		"cvLinearPolar", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("center",		CvPoint2D32f),
	("maxRadius",		ctypes.c_double),
	("flags",		ctypes.c_int),] )

cvConvertMaps = _rpythonic_function_(		"cvConvertMaps", ctypes.c_void_p, [
	("mapx",		ctypes.POINTER(ctypes.c_void_p)),
	("mapy",		ctypes.POINTER(ctypes.c_void_p)),
	("mapxy",		ctypes.POINTER(ctypes.c_void_p)),
	("mapalpha",		ctypes.POINTER(ctypes.c_void_p)),] )

cvLogPolar = _rpythonic_function_(		"cvLogPolar", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("center",		CvPoint2D32f),
	("M",		ctypes.c_double),
	("flags",		ctypes.c_int),] )

cvCreateStructuringElementEx = _rpythonic_function_(		"cvCreateStructuringElementEx", ctypes.POINTER(_IplConvKernel), [
	("cols",		ctypes.c_int),
	("rows",		ctypes.c_int),
	("anchor_x",		ctypes.c_int),
	("anchor_y",		ctypes.c_int),
	("shape",		ctypes.c_int),
	("values",		ctypes.POINTER(ctypes.c_int)),] )

cvReleaseStructuringElement = _rpythonic_function_(		"cvReleaseStructuringElement", ctypes.c_void_p, [
	("element",		ctypes.POINTER(ctypes.POINTER(_IplConvKernel))),] )

cvErode = _rpythonic_function_(		"cvErode", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("element",		ctypes.POINTER(_IplConvKernel)),
	("iterations",		ctypes.c_int),] )

cvDilate = _rpythonic_function_(		"cvDilate", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("element",		ctypes.POINTER(_IplConvKernel)),
	("iterations",		ctypes.c_int),] )

cvMorphologyEx = _rpythonic_function_(		"cvMorphologyEx", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("temp",		ctypes.POINTER(ctypes.c_void_p)),
	("element",		ctypes.POINTER(_IplConvKernel)),
	("operation",		ctypes.c_int),
	("iterations",		ctypes.c_int),] )

cvMoments = _rpythonic_function_(		"cvMoments", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("moments",		ctypes.POINTER(CvMoments)),
	("binary",		ctypes.c_int),] )

cvGetSpatialMoment = _rpythonic_function_(		"cvGetSpatialMoment", ctypes.c_double, [
	("moments",		ctypes.POINTER(CvMoments)),
	("x_order",		ctypes.c_int),
	("y_order",		ctypes.c_int),] )

cvGetCentralMoment = _rpythonic_function_(		"cvGetCentralMoment", ctypes.c_double, [
	("moments",		ctypes.POINTER(CvMoments)),
	("x_order",		ctypes.c_int),
	("y_order",		ctypes.c_int),] )

cvGetHuMoments = _rpythonic_function_(		"cvGetHuMoments", ctypes.c_void_p, [
	("moments",		ctypes.POINTER(CvMoments)),
	("hu_moments",		ctypes.POINTER(CvHuMoments)),] )

cvMatchTemplate = _rpythonic_function_(		"cvMatchTemplate", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("templ",		ctypes.POINTER(ctypes.c_void_p)),
	("result",		ctypes.POINTER(ctypes.c_void_p)),
	("method",		ctypes.c_int),] )

cvSampleLine = _rpythonic_function_(		"cvSampleLine", ctypes.c_int, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("pt1",		CvPoint),
	("pt2",		CvPoint),
	("buffer",		ctypes.POINTER(ctypes.c_void_p)),
	("connectivity",		ctypes.c_int),] )

cvGetNormalizedCentralMoment = _rpythonic_function_(		"cvGetNormalizedCentralMoment", ctypes.c_double, [
	("moments",		ctypes.POINTER(CvMoments)),
	("x_order",		ctypes.c_int),
	("y_order",		ctypes.c_int),] )

cvGetRectSubPix = _rpythonic_function_(		"cvGetRectSubPix", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("center",		CvPoint2D32f),] )

cvGetQuadrangleSubPix = _rpythonic_function_(		"cvGetQuadrangleSubPix", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("map_matrix",		ctypes.POINTER(CvMat)),] )

cvCalcEMD2 = _rpythonic_function_(		"cvCalcEMD2", ctypes.c_float, [
	("signature1",		ctypes.POINTER(ctypes.c_void_p)),
	("signature2",		ctypes.POINTER(ctypes.c_void_p)),
	("distance_type",		ctypes.c_int),
	("distance_func",		ctypes.CFUNCTYPE(ctypes.c_float, ctypes.POINTER(ctypes.c_float),ctypes.POINTER(ctypes.c_float),ctypes.POINTER(ctypes.c_void_p),)),
	("cost_matrix",		ctypes.POINTER(ctypes.c_void_p)),
	("flow",		ctypes.POINTER(ctypes.c_void_p)),
	("lower_bound",		ctypes.POINTER(ctypes.c_float)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvFindContours = _rpythonic_function_(		"cvFindContours", ctypes.c_int, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("first_contour",		ctypes.POINTER(ctypes.POINTER(CvSeq))),
	("header_size",		ctypes.c_int),
	("mode",		ctypes.c_int),
	("method",		ctypes.c_int),
	("offset",		CvPoint),] )

cvStartFindContours = _rpythonic_function_(		"cvStartFindContours", ctypes.POINTER(_CvContourScanner), [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("header_size",		ctypes.c_int),
	("mode",		ctypes.c_int),
	("method",		ctypes.c_int),
	("offset",		CvPoint),] )

cvFindNextContour = _rpythonic_function_(		"cvFindNextContour", ctypes.POINTER(CvSeq), [
	("scanner",		ctypes.POINTER(_CvContourScanner)),] )

cvSeqPopMulti = _rpythonic_function_(		"cvSeqPopMulti", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("elements",		ctypes.POINTER(ctypes.c_void_p)),
	("count",		ctypes.c_int),
	("in_front",		ctypes.c_int),] )

cvSeqInsert = _rpythonic_function_(		"cvSeqInsert", ctypes.POINTER(ctypes.c_char), [
	("seq",		ctypes.POINTER(CvSeq)),
	("before_index",		ctypes.c_int),
	("element",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSeqRemove = _rpythonic_function_(		"cvSeqRemove", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("index",		ctypes.c_int),] )

cvClearSeq = _rpythonic_function_(		"cvClearSeq", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),] )

cvGetSeqElem = _rpythonic_function_(		"cvGetSeqElem", ctypes.POINTER(ctypes.c_char), [
	("seq",		ctypes.POINTER(CvSeq)),
	("index",		ctypes.c_int),] )

cvSeqElemIdx = _rpythonic_function_(		"cvSeqElemIdx", ctypes.c_int, [
	("seq",		ctypes.POINTER(CvSeq)),
	("element",		ctypes.POINTER(ctypes.c_void_p)),
	("block",		ctypes.POINTER(ctypes.POINTER(CvSeqBlock))),] )

cvStartAppendToSeq = _rpythonic_function_(		"cvStartAppendToSeq", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("writer",		ctypes.POINTER(CvSeqWriter)),] )

cvCartToPolar = _rpythonic_function_(		"cvCartToPolar", ctypes.c_void_p, [
	("x",		ctypes.POINTER(ctypes.c_void_p)),
	("y",		ctypes.POINTER(ctypes.c_void_p)),
	("magnitude",		ctypes.POINTER(ctypes.c_void_p)),
	("angle",		ctypes.POINTER(ctypes.c_void_p)),
	("angle_in_degrees",		ctypes.c_int),] )

cvAbsDiffS = _rpythonic_function_(		"cvAbsDiffS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),] )

cvAbsDiff = _rpythonic_function_(		"cvAbsDiff", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMaxS = _rpythonic_function_(		"cvMaxS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		ctypes.c_double),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMinS = _rpythonic_function_(		"cvMinS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		ctypes.c_double),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMax = _rpythonic_function_(		"cvMax", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvGEMM = _rpythonic_function_(		"cvGEMM", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("alpha",		ctypes.c_double),
	("src3",		ctypes.POINTER(ctypes.c_void_p)),
	("beta",		ctypes.c_double),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("tABC",		ctypes.c_int),] )

cvSort = _rpythonic_function_(		"cvSort", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("idxmat",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),] )

cvCrossProduct = _rpythonic_function_(		"cvCrossProduct", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSolvePoly = _rpythonic_function_(		"cvSolvePoly", ctypes.c_void_p, [
	("coeffs",		ctypes.POINTER(CvMat)),
	("roots2",		ctypes.POINTER(CvMat)),
	("maxiter",		ctypes.c_int),
	("fig",		ctypes.c_int),] )

cvSolveCubic = _rpythonic_function_(		"cvSolveCubic", ctypes.c_int, [
	("coeffs",		ctypes.POINTER(CvMat)),
	("roots",		ctypes.POINTER(CvMat)),] )

cvRandShuffle = _rpythonic_function_(		"cvRandShuffle", ctypes.c_void_p, [
	("mat",		ctypes.POINTER(ctypes.c_void_p)),
	("rng",		ctypes.POINTER(ctypes.c_uint64)),
	("iter_factor",		ctypes.c_double),] )

cvSVD = _rpythonic_function_(		"cvSVD", ctypes.c_void_p, [
	("A",		ctypes.POINTER(ctypes.c_void_p)),
	("W",		ctypes.POINTER(ctypes.c_void_p)),
	("U",		ctypes.POINTER(ctypes.c_void_p)),
	("V",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),] )

cvSVBkSb = _rpythonic_function_(		"cvSVBkSb", ctypes.c_void_p, [
	("W",		ctypes.POINTER(ctypes.c_void_p)),
	("U",		ctypes.POINTER(ctypes.c_void_p)),
	("V",		ctypes.POINTER(ctypes.c_void_p)),
	("B",		ctypes.POINTER(ctypes.c_void_p)),
	("X",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),] )

cvInvert = _rpythonic_function_(		"cvInvert", ctypes.c_double, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("method",		ctypes.c_int),] )

cvSolve = _rpythonic_function_(		"cvSolve", ctypes.c_int, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("method",		ctypes.c_int),] )

cvDet = _rpythonic_function_(		"cvDet", ctypes.c_double, [("mat",		ctypes.c_void_p)] )

cvTrace = _rpythonic_function_(		"cvTrace", CvScalar, [("mat",		ctypes.c_void_p)] )

cvEigenVV = _rpythonic_function_(		"cvEigenVV", ctypes.c_void_p, [
	("mat",		ctypes.POINTER(ctypes.c_void_p)),
	("evects",		ctypes.POINTER(ctypes.c_void_p)),
	("evals",		ctypes.POINTER(ctypes.c_void_p)),
	("eps",		ctypes.c_double),
	("lowindex",		ctypes.c_int),
	("highindex",		ctypes.c_int),] )

cvMin = _rpythonic_function_(		"cvMin", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCmpS = _rpythonic_function_(		"cvCmpS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		ctypes.c_double),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("cmp_op",		ctypes.c_int),] )

cvCmp = _rpythonic_function_(		"cvCmp", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("cmp_op",		ctypes.c_int),] )

cvInRangeS = _rpythonic_function_(		"cvInRangeS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("lower",		CvScalar),
	("upper",		CvScalar),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvInRange = _rpythonic_function_(		"cvInRange", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("lower",		ctypes.POINTER(ctypes.c_void_p)),
	("upper",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvNot = _rpythonic_function_(		"cvNot", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvTransform = _rpythonic_function_(		"cvTransform", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("transmat",		ctypes.POINTER(CvMat)),
	("shiftvec",		ctypes.POINTER(CvMat)),] )

cvPerspectiveTransform = _rpythonic_function_(		"cvPerspectiveTransform", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mat",		ctypes.POINTER(CvMat)),] )

cvMulTransposed = _rpythonic_function_(		"cvMulTransposed", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("order",		ctypes.c_int),
	("delta",		ctypes.POINTER(ctypes.c_void_p)),
	("scale",		ctypes.c_double),] )

cvTranspose = _rpythonic_function_(		"cvTranspose", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCompleteSymm = _rpythonic_function_(		"cvCompleteSymm", ctypes.c_void_p, [
	("matrix",		ctypes.POINTER(CvMat)),
	("LtoR",		ctypes.c_int),] )

cvFlip = _rpythonic_function_(		"cvFlip", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("flip_mode",		ctypes.c_int),] )

cvSetIdentity = _rpythonic_function_(		"cvSetIdentity", ctypes.c_void_p, [
	("mat",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),] )

cvRange = _rpythonic_function_(		"cvRange", ctypes.POINTER(ctypes.c_void_p), [
	("mat",		ctypes.POINTER(ctypes.c_void_p)),
	("start",		ctypes.c_double),
	("end",		ctypes.c_double),] )

cvCalcCovarMatrix = _rpythonic_function_(		"cvCalcCovarMatrix", ctypes.c_void_p, [
	("vects",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("count",		ctypes.c_int),
	("cov_mat",		ctypes.POINTER(ctypes.c_void_p)),
	("avg",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),] )

cvCalcPCA = _rpythonic_function_(		"cvCalcPCA", ctypes.c_void_p, [
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("mean",		ctypes.POINTER(ctypes.c_void_p)),
	("eigenvals",		ctypes.POINTER(ctypes.c_void_p)),
	("eigenvects",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),] )

cvProjectPCA = _rpythonic_function_(		"cvProjectPCA", ctypes.c_void_p, [
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("mean",		ctypes.POINTER(ctypes.c_void_p)),
	("eigenvects",		ctypes.POINTER(ctypes.c_void_p)),
	("result",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMemStorageAllocString = _rpythonic_function_(		"cvMemStorageAllocString", CvString, [
	("storage",		ctypes.POINTER(CvMemStorage)),
	("ptr",		ctypes.POINTER(ctypes.c_char)),
	("C_len",		ctypes.c_int),] )

cvCreateSeq = _rpythonic_function_(		"cvCreateSeq", ctypes.POINTER(CvSeq), [
	("seq_flags",		ctypes.c_int),
	("header_size",		ctypes.c_int),
	("elem_size",		ctypes.c_int),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvSetSeqBlockSize = _rpythonic_function_(		"cvSetSeqBlockSize", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("delta_elems",		ctypes.c_int),] )

cvSeqPush = _rpythonic_function_(		"cvSeqPush", ctypes.POINTER(ctypes.c_char), [
	("seq",		ctypes.POINTER(CvSeq)),
	("element",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSeqPushFront = _rpythonic_function_(		"cvSeqPushFront", ctypes.POINTER(ctypes.c_char), [
	("seq",		ctypes.POINTER(CvSeq)),
	("element",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSeqPop = _rpythonic_function_(		"cvSeqPop", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("element",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSeqPopFront = _rpythonic_function_(		"cvSeqPopFront", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("element",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSeqPushMulti = _rpythonic_function_(		"cvSeqPushMulti", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("elements",		ctypes.POINTER(ctypes.c_void_p)),
	("count",		ctypes.c_int),
	("in_front",		ctypes.c_int),] )

cvNorm = _rpythonic_function_(		"cvNorm", ctypes.c_double, [
	("arr1",		ctypes.POINTER(ctypes.c_void_p)),
	("arr2",		ctypes.POINTER(ctypes.c_void_p)),
	("norm_type",		ctypes.c_int),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvNormalize = _rpythonic_function_(		"cvNormalize", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("a",		ctypes.c_double),
	("b",		ctypes.c_double),
	("norm_type",		ctypes.c_int),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvReduce = _rpythonic_function_(		"cvReduce", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("dim",		ctypes.c_int),
	("op",		ctypes.c_int),] )

cvDFT = _rpythonic_function_(		"cvDFT", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),
	("nonzero_rows",		ctypes.c_int),] )

cvMulSpectrums = _rpythonic_function_(		"cvMulSpectrums", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),] )

cvGetOptimalDFTSize = _rpythonic_function_(		"cvGetOptimalDFTSize", ctypes.c_int, [
	("size0",		ctypes.c_int),] )

cvBackProjectPCA = _rpythonic_function_(		"cvBackProjectPCA", ctypes.c_void_p, [
	("proj",		ctypes.POINTER(ctypes.c_void_p)),
	("mean",		ctypes.POINTER(ctypes.c_void_p)),
	("eigenvects",		ctypes.POINTER(ctypes.c_void_p)),
	("result",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMahalanobis = _rpythonic_function_(		"cvMahalanobis", ctypes.c_double, [
	("vec1",		ctypes.POINTER(ctypes.c_void_p)),
	("vec2",		ctypes.POINTER(ctypes.c_void_p)),
	("mat",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSum = _rpythonic_function_(		"cvSum", CvScalar, [("arr",		ctypes.c_void_p)] )

cvCountNonZero = _rpythonic_function_(		"cvCountNonZero", ctypes.c_int, [("arr",		ctypes.c_void_p)] )

cvAvg = _rpythonic_function_(		"cvAvg", CvScalar, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvAvgSdv = _rpythonic_function_(		"cvAvgSdv", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("mean",		ctypes.POINTER(CvScalar)),
	("std_dev",		ctypes.POINTER(CvScalar)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMinMaxLoc = _rpythonic_function_(		"cvMinMaxLoc", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("min_val",		ctypes.POINTER(ctypes.c_double)),
	("max_val",		ctypes.POINTER(ctypes.c_double)),
	("min_loc",		ctypes.POINTER(CvPoint)),
	("max_loc",		ctypes.POINTER(CvPoint)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvPow = _rpythonic_function_(		"cvPow", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("power",		ctypes.c_double),] )

cvCheckArr = _rpythonic_function_(		"cvCheckArr", ctypes.c_int, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),
	("min_val",		ctypes.c_double),
	("max_val",		ctypes.c_double),] )

cvExp = _rpythonic_function_(		"cvExp", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvLog = _rpythonic_function_(		"cvLog", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvPolarToCart = _rpythonic_function_(		"cvPolarToCart", ctypes.c_void_p, [
	("magnitude",		ctypes.POINTER(ctypes.c_void_p)),
	("angle",		ctypes.POINTER(ctypes.c_void_p)),
	("x",		ctypes.POINTER(ctypes.c_void_p)),
	("y",		ctypes.POINTER(ctypes.c_void_p)),
	("angle_in_degrees",		ctypes.c_int),] )

cvCbrt = _rpythonic_function_(		"cvCbrt", ctypes.c_float, [
	("value",		ctypes.c_float),] )

cvRandArr = _rpythonic_function_(		"cvRandArr", ctypes.c_void_p, [
	("rng",		ctypes.POINTER(ctypes.c_uint64)),
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("dist_type",		ctypes.c_int),
	("param1",		CvScalar),
	("param2",		CvScalar),] )

cvFastArctan = _rpythonic_function_(		"cvFastArctan", ctypes.c_float, [
	("y",		ctypes.c_float),
	("x",		ctypes.c_float),] )

cvDCT = _rpythonic_function_(		"cvDCT", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("flags",		ctypes.c_int),] )

cvSliceLength = _rpythonic_function_(		"cvSliceLength", ctypes.c_int, [
	("slice",		CvSlice),
	("seq",		ctypes.POINTER(CvSeq)),] )

cvCreateMemStorage = _rpythonic_function_(		"cvCreateMemStorage", ctypes.POINTER(CvMemStorage), [
	("block_size",		ctypes.c_int),] )

cvCreateChildMemStorage = _rpythonic_function_(		"cvCreateChildMemStorage", ctypes.POINTER(CvMemStorage), [
	("parent",		ctypes.POINTER(CvMemStorage)),] )

cvReleaseMemStorage = _rpythonic_function_(		"cvReleaseMemStorage", ctypes.c_void_p, [
	("storage",		ctypes.POINTER(ctypes.POINTER(CvMemStorage))),] )

cvClearMemStorage = _rpythonic_function_(		"cvClearMemStorage", ctypes.c_void_p, [
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvSaveMemStoragePos = _rpythonic_function_(		"cvSaveMemStoragePos", ctypes.c_void_p, [
	("storage",		ctypes.POINTER(CvMemStorage)),
	("pos",		ctypes.POINTER(CvMemStoragePos)),] )

cvRestoreMemStoragePos = _rpythonic_function_(		"cvRestoreMemStoragePos", ctypes.c_void_p, [
	("storage",		ctypes.POINTER(CvMemStorage)),
	("pos",		ctypes.POINTER(CvMemStoragePos)),] )

cvMemStorageAlloc = _rpythonic_function_(		"cvMemStorageAlloc", ctypes.POINTER(ctypes.c_void_p), [
	("storage",		ctypes.POINTER(CvMemStorage)),
	("size",		ctypes.c_size_t),] )

cvCalcArrBackProject = _rpythonic_function_(		"cvCalcArrBackProject", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("hist",		ctypes.POINTER(CvHistogram)),] )

cvCalcArrBackProjectPatch = _rpythonic_function_(		"cvCalcArrBackProjectPatch", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("C_range",		CvSize),
	("hist",		ctypes.POINTER(CvHistogram)),
	("method",		ctypes.c_int),
	("factor",		ctypes.c_double),] )

cvCalcProbDensity = _rpythonic_function_(		"cvCalcProbDensity", ctypes.c_void_p, [
	("hist1",		ctypes.POINTER(CvHistogram)),
	("hist2",		ctypes.POINTER(CvHistogram)),
	("dst_hist",		ctypes.POINTER(CvHistogram)),
	("scale",		ctypes.c_double),] )

cvEqualizeHist = _rpythonic_function_(		"cvEqualizeHist", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSnakeImage = _rpythonic_function_(		"cvSnakeImage", ctypes.c_void_p, [
	("image",		ctypes.POINTER(_IplImage)),
	("points",		ctypes.POINTER(CvPoint)),
	("length",		ctypes.c_int),
	("alpha",		ctypes.POINTER(ctypes.c_float)),
	("beta",		ctypes.POINTER(ctypes.c_float)),
	("gamma",		ctypes.POINTER(ctypes.c_float)),
	("coeff_usage",		ctypes.c_int),
	("win",		CvSize),
	("criteria",		CvTermCriteria),
	("calc_gradient",		ctypes.c_int),] )

cvDistTransform = _rpythonic_function_(		"cvDistTransform", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("distance_type",		ctypes.c_int),
	("mask_size",		ctypes.c_int),
	("mask",		ctypes.POINTER(ctypes.c_float)),
	("labels",		ctypes.POINTER(ctypes.c_void_p)),] )

cvAdaptiveThreshold = _rpythonic_function_(		"cvAdaptiveThreshold", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("max_value",		ctypes.c_double),
	("adaptive_method",		ctypes.c_int),
	("threshold_type",		ctypes.c_int),
	("block_size",		ctypes.c_int),
	("param1",		ctypes.c_double),] )

cvThreshold = _rpythonic_function_(		"cvThreshold", ctypes.c_double, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("threshold",		ctypes.c_double),
	("max_value",		ctypes.c_double),
	("threshold_type",		ctypes.c_int),] )

cvFloodFill = _rpythonic_function_(		"cvFloodFill", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("seed_point",		CvPoint),
	("new_val",		CvScalar),
	("lo_diff",		CvScalar),
	("up_diff",		CvScalar),
	("comp",		ctypes.POINTER(CvConnectedComp)),
	("flags",		ctypes.c_int),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCanny = _rpythonic_function_(		"cvCanny", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("edges",		ctypes.POINTER(ctypes.c_void_p)),
	("threshold1",		ctypes.c_double),
	("threshold2",		ctypes.c_double),
	("aperture_size",		ctypes.c_int),] )

cvCornerEigenValsAndVecs = _rpythonic_function_(		"cvCornerEigenValsAndVecs", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("eigenvv",		ctypes.POINTER(ctypes.c_void_p)),
	("block_size",		ctypes.c_int),
	("aperture_size",		ctypes.c_int),] )

cvPreCornerDetect = _rpythonic_function_(		"cvPreCornerDetect", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("corners",		ctypes.POINTER(ctypes.c_void_p)),
	("aperture_size",		ctypes.c_int),] )

cvCornerMinEigenVal = _rpythonic_function_(		"cvCornerMinEigenVal", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("eigenval",		ctypes.POINTER(ctypes.c_void_p)),
	("block_size",		ctypes.c_int),
	("aperture_size",		ctypes.c_int),] )

cvCornerHarris = _rpythonic_function_(		"cvCornerHarris", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("harris_responce",		ctypes.POINTER(ctypes.c_void_p)),
	("block_size",		ctypes.c_int),
	("aperture_size",		ctypes.c_int),
	("k",		ctypes.c_double),] )

cvFindCornerSubPix = _rpythonic_function_(		"cvFindCornerSubPix", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("corners",		ctypes.POINTER(CvPoint2D32f)),
	("count",		ctypes.c_int),
	("win",		CvSize),
	("zero_zone",		CvSize),
	("criteria",		CvTermCriteria),] )

cvGoodFeaturesToTrack = _rpythonic_function_(		"cvGoodFeaturesToTrack", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("eig_image",		ctypes.POINTER(ctypes.c_void_p)),
	("temp_image",		ctypes.POINTER(ctypes.c_void_p)),
	("corners",		ctypes.POINTER(CvPoint2D32f)),
	("corner_count",		ctypes.POINTER(ctypes.c_int)),
	("quality_level",		ctypes.c_double),
	("min_distance",		ctypes.c_double),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),
	("block_size",		ctypes.c_int),
	("use_harris",		ctypes.c_int),
	("k",		ctypes.c_double),] )

cvHoughLines2 = _rpythonic_function_(		"cvHoughLines2", ctypes.POINTER(CvSeq), [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("line_storage",		ctypes.POINTER(ctypes.c_void_p)),
	("method",		ctypes.c_int),
	("rho",		ctypes.c_double),
	("theta",		ctypes.c_double),
	("threshold",		ctypes.c_int),
	("param1",		ctypes.c_double),
	("param2",		ctypes.c_double),] )

cvHoughCircles = _rpythonic_function_(		"cvHoughCircles", ctypes.POINTER(CvSeq), [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("circle_storage",		ctypes.POINTER(ctypes.c_void_p)),
	("method",		ctypes.c_int),
	("dp",		ctypes.c_double),
	("min_dist",		ctypes.c_double),
	("param1",		ctypes.c_double),
	("param2",		ctypes.c_double),
	("min_radius",		ctypes.c_int),
	("max_radius",		ctypes.c_int),] )

cvFitLine = _rpythonic_function_(		"cvFitLine", ctypes.c_void_p, [
	("points",		ctypes.POINTER(ctypes.c_void_p)),
	("dist_type",		ctypes.c_int),
	("param",		ctypes.c_double),
	("reps",		ctypes.c_double),
	("aeps",		ctypes.c_double),
	("line",		ctypes.POINTER(ctypes.c_float)),] )

cvCreateKDTree = _rpythonic_function_(		"cvCreateKDTree", ctypes.POINTER(CvFeatureTree), [
	("desc",		ctypes.POINTER(CvMat)),] )

cvCreateSpillTree = _rpythonic_function_(		"cvCreateSpillTree", ctypes.POINTER(CvFeatureTree), [
	("raw_data",		ctypes.POINTER(CvMat)),
	("naive",		ctypes.c_int),
	("rho",		ctypes.c_double),
	("tau",		ctypes.c_double),] )

cvFindFeatures = _rpythonic_function_(		"cvFindFeatures", ctypes.c_void_p, [
	("tr",		ctypes.POINTER(CvFeatureTree)),
	("query_points",		ctypes.POINTER(CvMat)),
	("indices",		ctypes.POINTER(CvMat)),
	("dist",		ctypes.POINTER(CvMat)),
	("k",		ctypes.c_int),
	("emax",		ctypes.c_int),] )

cvReleaseFeatureTree = _rpythonic_function_(		"cvReleaseFeatureTree", ctypes.c_void_p, [
	("tr",		ctypes.POINTER(CvFeatureTree)),] )

cvFindFeaturesBoxed = _rpythonic_function_(		"cvFindFeaturesBoxed", ctypes.c_int, [
	("tr",		ctypes.POINTER(CvFeatureTree)),
	("bounds_min",		ctypes.POINTER(CvMat)),
	("bounds_max",		ctypes.POINTER(CvMat)),
	("out_indices",		ctypes.POINTER(CvMat)),] )

cvCreateLSH = _rpythonic_function_(		"cvCreateLSH", ctypes.POINTER(CvLSH), [
	("ops",		ctypes.POINTER(CvLSHOperations)),
	("d",		ctypes.c_int),
	("L",		ctypes.c_int),
	("k",		ctypes.c_int),
	("C_type",		ctypes.c_int),
	("r",		ctypes.c_double),
	("seed",		ctypes.c_int64),] )

cvCreateMemoryLSH = _rpythonic_function_(		"cvCreateMemoryLSH", ctypes.POINTER(CvLSH), [
	("d",		ctypes.c_int),
	("n",		ctypes.c_int),
	("L",		ctypes.c_int),
	("k",		ctypes.c_int),
	("C_type",		ctypes.c_int),
	("r",		ctypes.c_double),
	("seed",		ctypes.c_int64),] )

cvReleaseLSH = _rpythonic_function_(		"cvReleaseLSH", ctypes.c_void_p, [
	("lsh",		ctypes.POINTER(ctypes.POINTER(CvLSH))),] )

LSHSize = _rpythonic_function_(		"LSHSize", ctypes.c_uint, [
	("lsh",		ctypes.POINTER(CvLSH)),] )

cvLSHAdd = _rpythonic_function_(		"cvLSHAdd", ctypes.c_void_p, [
	("lsh",		ctypes.POINTER(CvLSH)),
	("data",		ctypes.POINTER(CvMat)),
	("indices",		ctypes.POINTER(CvMat)),] )

cvLSHRemove = _rpythonic_function_(		"cvLSHRemove", ctypes.c_void_p, [
	("lsh",		ctypes.POINTER(CvLSH)),
	("indices",		ctypes.POINTER(CvMat)),] )

cvLSHQuery = _rpythonic_function_(		"cvLSHQuery", ctypes.c_void_p, [
	("lsh",		ctypes.POINTER(CvLSH)),
	("query_points",		ctypes.POINTER(CvMat)),
	("indices",		ctypes.POINTER(CvMat)),
	("dist",		ctypes.POINTER(CvMat)),
	("k",		ctypes.c_int),
	("emax",		ctypes.c_int),] )

cvSURFParams = _rpythonic_function_(		"cvSURFParams", CvSURFParams, [
	("hessianThreshold",		ctypes.c_double),
	("extended",		ctypes.c_int),] )

cvExtractSURF = _rpythonic_function_(		"cvExtractSURF", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),
	("keypoints",		ctypes.POINTER(ctypes.POINTER(CvSeq))),
	("descriptors",		ctypes.POINTER(ctypes.POINTER(CvSeq))),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("params",		CvSURFParams),
	("useProvidedKeyPts",		ctypes.c_int),] )

cvMSERParams = _rpythonic_function_(		"cvMSERParams", CvMSERParams, [
	("delta",		ctypes.c_int),
	("min_area",		ctypes.c_int),
	("max_area",		ctypes.c_int),
	("max_variation",		ctypes.c_float),
	("min_diversity",		ctypes.c_float),
	("max_evolution",		ctypes.c_int),
	("area_threshold",		ctypes.c_double),
	("min_margin",		ctypes.c_double),
	("edge_blur_size",		ctypes.c_int),] )

cvExtractMSER = _rpythonic_function_(		"cvExtractMSER", ctypes.c_void_p, [
	("_img",		ctypes.POINTER(ctypes.c_void_p)),
	("_mask",		ctypes.POINTER(ctypes.c_void_p)),
	("contours",		ctypes.POINTER(ctypes.POINTER(CvSeq))),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("params",		CvMSERParams),] )

cvGetStarKeypoints = _rpythonic_function_(		"cvGetStarKeypoints", ctypes.POINTER(CvSeq), [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("params",		CvStarDetectorParams),] )

cvLoadHaarClassifierCascade = _rpythonic_function_(		"cvLoadHaarClassifierCascade", ctypes.POINTER(CvHaarClassifierCascade), [
	("directory",		ctypes.POINTER(ctypes.c_char)),
	("orig_window_size",		CvSize),] )

cvReleaseHaarClassifierCascade = _rpythonic_function_(		"cvReleaseHaarClassifierCascade", ctypes.c_void_p, [
	("cascade",		ctypes.POINTER(ctypes.POINTER(CvHaarClassifierCascade))),] )

cvHaarDetectObjects = _rpythonic_function_(		"cvHaarDetectObjects", ctypes.POINTER(CvSeq), [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("cascade",		ctypes.POINTER(CvHaarClassifierCascade)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("scale_factor",		ctypes.c_double),
	("min_neighbors",		ctypes.c_int),
	("flags",		ctypes.c_int),
	("min_size",		CvSize),] )

cvSetImagesForHaarClassifierCascade = _rpythonic_function_(		"cvSetImagesForHaarClassifierCascade", ctypes.c_void_p, [
	("cascade",		ctypes.POINTER(CvHaarClassifierCascade)),
	("sum",		ctypes.POINTER(ctypes.c_void_p)),
	("sqsum",		ctypes.POINTER(ctypes.c_void_p)),
	("tilted_sum",		ctypes.POINTER(ctypes.c_void_p)),
	("scale",		ctypes.c_double),] )

cvRunHaarClassifierCascade = _rpythonic_function_(		"cvRunHaarClassifierCascade", ctypes.c_int, [
	("cascade",		ctypes.POINTER(CvHaarClassifierCascade)),
	("pt",		CvPoint),
	("start_stage",		ctypes.c_int),] )

cvUndistort2 = _rpythonic_function_(		"cvUndistort2", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("distortion_coeffs",		ctypes.POINTER(CvMat)),
	("new_camera_matrix",		ctypes.POINTER(CvMat)),] )

cvInitUndistortMap = _rpythonic_function_(		"cvInitUndistortMap", ctypes.c_void_p, [
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("distortion_coeffs",		ctypes.POINTER(CvMat)),
	("mapx",		ctypes.POINTER(ctypes.c_void_p)),
	("mapy",		ctypes.POINTER(ctypes.c_void_p)),] )

cvInitUndistortRectifyMap = _rpythonic_function_(		"cvInitUndistortRectifyMap", ctypes.c_void_p, [
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("dist_coeffs",		ctypes.POINTER(CvMat)),
	("R",		ctypes.POINTER(CvMat)),
	("new_camera_matrix",		ctypes.POINTER(CvMat)),
	("mapx",		ctypes.POINTER(ctypes.c_void_p)),
	("mapy",		ctypes.POINTER(ctypes.c_void_p)),] )

cvUndistortPoints = _rpythonic_function_(		"cvUndistortPoints", ctypes.c_void_p, [
	("src",		ctypes.POINTER(CvMat)),
	("dst",		ctypes.POINTER(CvMat)),
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("dist_coeffs",		ctypes.POINTER(CvMat)),
	("R",		ctypes.POINTER(CvMat)),
	("P",		ctypes.POINTER(CvMat)),] )

cvGetOptimalNewCameraMatrix = _rpythonic_function_(		"cvGetOptimalNewCameraMatrix", ctypes.c_void_p, [
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("dist_coeffs",		ctypes.POINTER(CvMat)),
	("image_size",		CvSize),
	("alpha",		ctypes.c_double),
	("new_camera_matrix",		ctypes.POINTER(CvMat)),
	("new_imag_size",		CvSize),
	("valid_pixel_ROI",		ctypes.POINTER(CvRect)),] )

cvRodrigues2 = _rpythonic_function_(		"cvRodrigues2", ctypes.c_int, [
	("src",		ctypes.POINTER(CvMat)),
	("dst",		ctypes.POINTER(CvMat)),
	("jacobian",		ctypes.POINTER(CvMat)),] )

cvFindHomography = _rpythonic_function_(		"cvFindHomography", ctypes.c_int, [
	("src_points",		ctypes.POINTER(CvMat)),
	("dst_points",		ctypes.POINTER(CvMat)),
	("homography",		ctypes.POINTER(CvMat)),
	("method",		ctypes.c_int),
	("ransacReprojThreshold",		ctypes.c_double),
	("mask",		ctypes.POINTER(CvMat)),] )

cvRQDecomp3x3 = _rpythonic_function_(		"cvRQDecomp3x3", ctypes.c_void_p, [
	("matrixM",		ctypes.POINTER(CvMat)),
	("matrixR",		ctypes.POINTER(CvMat)),
	("matrixQ",		ctypes.POINTER(CvMat)),
	("matrixQx",		ctypes.POINTER(CvMat)),
	("matrixQy",		ctypes.POINTER(CvMat)),
	("matrixQz",		ctypes.POINTER(CvMat)),
	("eulerAngles",		ctypes.POINTER(CvPoint3D64f)),] )

cvDecomposeProjectionMatrix = _rpythonic_function_(		"cvDecomposeProjectionMatrix", ctypes.c_void_p, [
	("projMatr",		ctypes.POINTER(CvMat)),
	("calibMatr",		ctypes.POINTER(CvMat)),
	("rotMatr",		ctypes.POINTER(CvMat)),
	("posVect",		ctypes.POINTER(CvMat)),
	("rotMatrX",		ctypes.POINTER(CvMat)),
	("rotMatrY",		ctypes.POINTER(CvMat)),
	("rotMatrZ",		ctypes.POINTER(CvMat)),
	("eulerAngles",		ctypes.POINTER(CvPoint3D64f)),] )

cvCalcMatMulDeriv = _rpythonic_function_(		"cvCalcMatMulDeriv", ctypes.c_void_p, [
	("A",		ctypes.POINTER(CvMat)),
	("B",		ctypes.POINTER(CvMat)),
	("dABdA",		ctypes.POINTER(CvMat)),
	("dABdB",		ctypes.POINTER(CvMat)),] )

cvComposeRT = _rpythonic_function_(		"cvComposeRT", ctypes.c_void_p, [
	("_rvec1",		ctypes.POINTER(CvMat)),
	("_tvec1",		ctypes.POINTER(CvMat)),
	("_rvec2",		ctypes.POINTER(CvMat)),
	("_tvec2",		ctypes.POINTER(CvMat)),
	("_rvec3",		ctypes.POINTER(CvMat)),
	("_tvec3",		ctypes.POINTER(CvMat)),
	("dr3dr1",		ctypes.POINTER(CvMat)),
	("dr3dt1",		ctypes.POINTER(CvMat)),
	("dr3dr2",		ctypes.POINTER(CvMat)),
	("dr3dt2",		ctypes.POINTER(CvMat)),
	("dt3dr1",		ctypes.POINTER(CvMat)),
	("dt3dt1",		ctypes.POINTER(CvMat)),
	("dt3dr2",		ctypes.POINTER(CvMat)),
	("dt3dt2",		ctypes.POINTER(CvMat)),] )

cvProjectPoints2 = _rpythonic_function_(		"cvProjectPoints2", ctypes.c_void_p, [
	("object_points",		ctypes.POINTER(CvMat)),
	("rotation_vector",		ctypes.POINTER(CvMat)),
	("translation_vector",		ctypes.POINTER(CvMat)),
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("distortion_coeffs",		ctypes.POINTER(CvMat)),
	("image_points",		ctypes.POINTER(CvMat)),
	("dpdrot",		ctypes.POINTER(CvMat)),
	("dpdt",		ctypes.POINTER(CvMat)),
	("dpdf",		ctypes.POINTER(CvMat)),
	("dpdc",		ctypes.POINTER(CvMat)),
	("dpddist",		ctypes.POINTER(CvMat)),
	("aspect_ratio",		ctypes.c_double),] )

cvFindExtrinsicCameraParams2 = _rpythonic_function_(		"cvFindExtrinsicCameraParams2", ctypes.c_void_p, [
	("object_points",		ctypes.POINTER(CvMat)),
	("image_points",		ctypes.POINTER(CvMat)),
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("distortion_coeffs",		ctypes.POINTER(CvMat)),
	("rotation_vector",		ctypes.POINTER(CvMat)),
	("translation_vector",		ctypes.POINTER(CvMat)),
	("use_extrinsic_guess",		ctypes.c_int),] )

cvInitIntrinsicParams2D = _rpythonic_function_(		"cvInitIntrinsicParams2D", ctypes.c_void_p, [
	("object_points",		ctypes.POINTER(CvMat)),
	("image_points",		ctypes.POINTER(CvMat)),
	("npoints",		ctypes.POINTER(CvMat)),
	("image_size",		CvSize),
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("aspect_ratio",		ctypes.c_double),] )

cvCheckChessboard = _rpythonic_function_(		"cvCheckChessboard", ctypes.c_int, [
	("src",		ctypes.POINTER(_IplImage)),
	("size",		CvSize),] )

cvFindChessboardCorners = _rpythonic_function_(		"cvFindChessboardCorners", ctypes.c_int, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("pattern_size",		CvSize),
	("corners",		ctypes.POINTER(CvPoint2D32f)),
	("corner_count",		ctypes.POINTER(ctypes.c_int)),
	("flags",		ctypes.c_int),] )

cvDrawChessboardCorners = _rpythonic_function_(		"cvDrawChessboardCorners", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("pattern_size",		CvSize),
	("corners",		ctypes.POINTER(CvPoint2D32f)),
	("count",		ctypes.c_int),
	("pattern_was_found",		ctypes.c_int),] )

cvCalibrateCamera2 = _rpythonic_function_(		"cvCalibrateCamera2", ctypes.c_double, [
	("object_points",		ctypes.POINTER(CvMat)),
	("image_points",		ctypes.POINTER(CvMat)),
	("point_counts",		ctypes.POINTER(CvMat)),
	("image_size",		CvSize),
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("distortion_coeffs",		ctypes.POINTER(CvMat)),
	("rotation_vectors",		ctypes.POINTER(CvMat)),
	("translation_vectors",		ctypes.POINTER(CvMat)),
	("flags",		ctypes.c_int),] )

cvCalibrationMatrixValues = _rpythonic_function_(		"cvCalibrationMatrixValues", ctypes.c_void_p, [
	("camera_matrix",		ctypes.POINTER(CvMat)),
	("image_size",		CvSize),
	("aperture_width",		ctypes.c_double),
	("aperture_height",		ctypes.c_double),
	("fovx",		ctypes.POINTER(ctypes.c_double)),
	("fovy",		ctypes.POINTER(ctypes.c_double)),
	("focal_length",		ctypes.POINTER(ctypes.c_double)),
	("principal_point",		ctypes.POINTER(CvPoint2D64f)),
	("pixel_aspect_ratio",		ctypes.POINTER(ctypes.c_double)),] )

cvStereoCalibrate = _rpythonic_function_(		"cvStereoCalibrate", ctypes.c_double, [
	("object_points",		ctypes.POINTER(CvMat)),
	("image_points1",		ctypes.POINTER(CvMat)),
	("image_points2",		ctypes.POINTER(CvMat)),
	("npoints",		ctypes.POINTER(CvMat)),
	("camera_matrix1",		ctypes.POINTER(CvMat)),
	("dist_coeffs1",		ctypes.POINTER(CvMat)),
	("camera_matrix2",		ctypes.POINTER(CvMat)),
	("dist_coeffs2",		ctypes.POINTER(CvMat)),
	("image_size",		CvSize),
	("R",		ctypes.POINTER(CvMat)),
	("T",		ctypes.POINTER(CvMat)),
	("E",		ctypes.POINTER(CvMat)),
	("F",		ctypes.POINTER(CvMat)),
	("term_crit",		CvTermCriteria),
	("flags",		ctypes.c_int),] )

cvStereoRectify = _rpythonic_function_(		"cvStereoRectify", ctypes.c_void_p, [
	("camera_matrix1",		ctypes.POINTER(CvMat)),
	("camera_matrix2",		ctypes.POINTER(CvMat)),
	("dist_coeffs1",		ctypes.POINTER(CvMat)),
	("dist_coeffs2",		ctypes.POINTER(CvMat)),
	("image_size",		CvSize),
	("R",		ctypes.POINTER(CvMat)),
	("T",		ctypes.POINTER(CvMat)),
	("R1",		ctypes.POINTER(CvMat)),
	("R2",		ctypes.POINTER(CvMat)),
	("P1",		ctypes.POINTER(CvMat)),
	("P2",		ctypes.POINTER(CvMat)),
	("Q",		ctypes.POINTER(CvMat)),
	("flags",		ctypes.c_int),
	("alpha",		ctypes.c_double),
	("new_image_size",		CvSize),
	("valid_pix_ROI1",		ctypes.POINTER(CvRect)),
	("valid_pix_ROI2",		ctypes.POINTER(CvRect)),] )

cvStereoRectifyUncalibrated = _rpythonic_function_(		"cvStereoRectifyUncalibrated", ctypes.c_int, [
	("points1",		ctypes.POINTER(CvMat)),
	("points2",		ctypes.POINTER(CvMat)),
	("F",		ctypes.POINTER(CvMat)),
	("img_size",		CvSize),
	("H1",		ctypes.POINTER(CvMat)),
	("H2",		ctypes.POINTER(CvMat)),
	("threshold",		ctypes.c_double),] )

cvCreatePOSITObject = _rpythonic_function_(		"cvCreatePOSITObject", ctypes.POINTER(CvPOSITObject), [
	("points",		ctypes.POINTER(CvPoint3D32f)),
	("point_count",		ctypes.c_int),] )

cvPOSIT = _rpythonic_function_(		"cvPOSIT", ctypes.c_void_p, [
	("posit_object",		ctypes.POINTER(CvPOSITObject)),
	("image_points",		ctypes.POINTER(CvPoint2D32f)),
	("focal_length",		ctypes.c_double),
	("criteria",		CvTermCriteria),
	("rotation_matrix",		ctypes.POINTER(ctypes.c_float)),
	("translation_vector",		ctypes.POINTER(ctypes.c_float)),] )

cvRANSACUpdateNumIters = _rpythonic_function_(		"cvRANSACUpdateNumIters", ctypes.c_int, [
	("p",		ctypes.c_double),
	("err_prob",		ctypes.c_double),
	("model_points",		ctypes.c_int),
	("max_iters",		ctypes.c_int),] )

cvReleasePOSITObject = _rpythonic_function_(		"cvReleasePOSITObject", ctypes.c_void_p, [
	("posit_object",		ctypes.POINTER(ctypes.POINTER(CvPOSITObject))),] )

cvConvertPointsHomogeneous = _rpythonic_function_(		"cvConvertPointsHomogeneous", ctypes.c_void_p, [
	("src",		ctypes.POINTER(CvMat)),
	("dst",		ctypes.POINTER(CvMat)),] )

cvFindFundamentalMat = _rpythonic_function_(		"cvFindFundamentalMat", ctypes.c_int, [
	("points1",		ctypes.POINTER(CvMat)),
	("points2",		ctypes.POINTER(CvMat)),
	("fundamental_matrix",		ctypes.POINTER(CvMat)),
	("method",		ctypes.c_int),
	("param1",		ctypes.c_double),
	("param2",		ctypes.c_double),
	("status",		ctypes.POINTER(CvMat)),] )

cvComputeCorrespondEpilines = _rpythonic_function_(		"cvComputeCorrespondEpilines", ctypes.c_void_p, [
	("points",		ctypes.POINTER(CvMat)),
	("which_image",		ctypes.c_int),
	("fundamental_matrix",		ctypes.POINTER(CvMat)),
	("correspondent_lines",		ctypes.POINTER(CvMat)),] )

cvTriangulatePoints = _rpythonic_function_(		"cvTriangulatePoints", ctypes.c_void_p, [
	("projMatr1",		ctypes.POINTER(CvMat)),
	("projMatr2",		ctypes.POINTER(CvMat)),
	("projPoints1",		ctypes.POINTER(CvMat)),
	("projPoints2",		ctypes.POINTER(CvMat)),
	("points4D",		ctypes.POINTER(CvMat)),] )

cvCorrectMatches = _rpythonic_function_(		"cvCorrectMatches", ctypes.c_void_p, [
	("F",		ctypes.POINTER(CvMat)),
	("points1",		ctypes.POINTER(CvMat)),
	("points2",		ctypes.POINTER(CvMat)),
	("new_points1",		ctypes.POINTER(CvMat)),
	("new_points2",		ctypes.POINTER(CvMat)),] )

cvCreateStereoBMState = _rpythonic_function_(		"cvCreateStereoBMState", ctypes.POINTER(CvStereoBMState), [
	("preset",		ctypes.c_int),
	("numberOfDisparities",		ctypes.c_int),] )

cvReleaseStereoBMState = _rpythonic_function_(		"cvReleaseStereoBMState", ctypes.c_void_p, [
	("state",		ctypes.POINTER(ctypes.POINTER(CvStereoBMState))),] )

cvFindStereoCorrespondenceBM = _rpythonic_function_(		"cvFindStereoCorrespondenceBM", ctypes.c_void_p, [
	("left",		ctypes.POINTER(ctypes.c_void_p)),
	("right",		ctypes.POINTER(ctypes.c_void_p)),
	("disparity",		ctypes.POINTER(ctypes.c_void_p)),
	("state",		ctypes.POINTER(CvStereoBMState)),] )

cvGetValidDisparityROI = _rpythonic_function_(		"cvGetValidDisparityROI", CvRect, [
	("roi1",		CvRect),
	("roi2",		CvRect),
	("minDisparity",		ctypes.c_int),
	("numberOfDisparities",		ctypes.c_int),
	("SADWindowSize",		ctypes.c_int),] )

cvValidateDisparity = _rpythonic_function_(		"cvValidateDisparity", ctypes.c_void_p, [
	("disparity",		ctypes.POINTER(ctypes.c_void_p)),
	("cost",		ctypes.POINTER(ctypes.c_void_p)),
	("minDisparity",		ctypes.c_int),
	("numberOfDisparities",		ctypes.c_int),
	("disp12MaxDiff",		ctypes.c_int),] )

cvReprojectImageTo3D = _rpythonic_function_(		"cvReprojectImageTo3D", ctypes.c_void_p, [
	("disparityImage",		ctypes.POINTER(ctypes.c_void_p)),
	("_3dImage",		ctypes.POINTER(ctypes.c_void_p)),
	("Q",		ctypes.POINTER(CvMat)),
	("handleMissingValues",		ctypes.c_int),] )

cvCreateStereoGCState = _rpythonic_function_(		"cvCreateStereoGCState", ctypes.POINTER(CvStereoGCState), [
	("numberOfDisparities",		ctypes.c_int),
	("maxIters",		ctypes.c_int),] )

cvReleaseStereoGCState = _rpythonic_function_(		"cvReleaseStereoGCState", ctypes.c_void_p, [
	("state",		ctypes.POINTER(ctypes.POINTER(CvStereoGCState))),] )

cvFindStereoCorrespondenceGC = _rpythonic_function_(		"cvFindStereoCorrespondenceGC", ctypes.c_void_p, [
	("left",		ctypes.POINTER(ctypes.c_void_p)),
	("right",		ctypes.POINTER(ctypes.c_void_p)),
	("disparityLeft",		ctypes.POINTER(ctypes.c_void_p)),
	("disparityRight",		ctypes.POINTER(ctypes.c_void_p)),
	("state",		ctypes.POINTER(CvStereoGCState)),
	("useDisparityGuess",		ctypes.c_int),] )

cvStartWriteSeq = _rpythonic_function_(		"cvStartWriteSeq", ctypes.c_void_p, [
	("seq_flags",		ctypes.c_int),
	("header_size",		ctypes.c_int),
	("elem_size",		ctypes.c_int),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("writer",		ctypes.POINTER(CvSeqWriter)),] )

cvEndWriteSeq = _rpythonic_function_(		"cvEndWriteSeq", ctypes.POINTER(CvSeq), [
	("writer",		ctypes.POINTER(CvSeqWriter)),] )

cvFlushSeqWriter = _rpythonic_function_(		"cvFlushSeqWriter", ctypes.c_void_p, [
	("writer",		ctypes.POINTER(CvSeqWriter)),] )

cvStartReadSeq = _rpythonic_function_(		"cvStartReadSeq", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("reader",		ctypes.POINTER(CvSeqReader)),
	("reverse",		ctypes.c_int),] )

cvGetSeqReaderPos = _rpythonic_function_(		"cvGetSeqReaderPos", ctypes.c_int, [
	("reader",		ctypes.POINTER(CvSeqReader)),] )

cvSetSeqReaderPos = _rpythonic_function_(		"cvSetSeqReaderPos", ctypes.c_void_p, [
	("reader",		ctypes.POINTER(CvSeqReader)),
	("index",		ctypes.c_int),
	("is_relative",		ctypes.c_int),] )

cvCvtSeqToArray = _rpythonic_function_(		"cvCvtSeqToArray", ctypes.POINTER(ctypes.c_void_p), [
	("seq",		ctypes.POINTER(CvSeq)),
	("elements",		ctypes.POINTER(ctypes.c_void_p)),
	("slice",		CvSlice),] )

cvMakeSeqHeaderForArray = _rpythonic_function_(		"cvMakeSeqHeaderForArray", ctypes.POINTER(CvSeq), [
	("seq_type",		ctypes.c_int),
	("header_size",		ctypes.c_int),
	("elem_size",		ctypes.c_int),
	("elements",		ctypes.POINTER(ctypes.c_void_p)),
	("total",		ctypes.c_int),
	("seq",		ctypes.POINTER(CvSeq)),
	("block",		ctypes.POINTER(CvSeqBlock)),] )

cvCreateGraphScanner = _rpythonic_function_(		"cvCreateGraphScanner", ctypes.POINTER(CvGraphScanner), [
	("graph",		ctypes.POINTER(CvGraph)),
	("vtx",		ctypes.POINTER(CvGraphVtx)),
	("mask",		ctypes.c_int),] )

cvReleaseGraphScanner = _rpythonic_function_(		"cvReleaseGraphScanner", ctypes.c_void_p, [
	("scanner",		ctypes.POINTER(ctypes.POINTER(CvGraphScanner))),] )

cvNextGraphItem = _rpythonic_function_(		"cvNextGraphItem", ctypes.c_int, [
	("scanner",		ctypes.POINTER(CvGraphScanner)),] )

cvCloneGraph = _rpythonic_function_(		"cvCloneGraph", ctypes.POINTER(CvGraph), [
	("graph",		ctypes.POINTER(CvGraph)),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvLine = _rpythonic_function_(		"cvLine", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("pt1",		CvPoint),
	("pt2",		CvPoint),
	("color",		CvScalar),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvRectangle = _rpythonic_function_(		"cvRectangle", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("pt1",		CvPoint),
	("pt2",		CvPoint),
	("color",		CvScalar),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvSeqSlice = _rpythonic_function_(		"cvSeqSlice", ctypes.POINTER(CvSeq), [
	("seq",		ctypes.POINTER(CvSeq)),
	("slice",		CvSlice),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("copy_data",		ctypes.c_int),] )

cvSeqRemoveSlice = _rpythonic_function_(		"cvSeqRemoveSlice", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("slice",		CvSlice),] )

cvSeqInsertSlice = _rpythonic_function_(		"cvSeqInsertSlice", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("before_index",		ctypes.c_int),
	("from_arr",		ctypes.POINTER(ctypes.c_void_p)),] )

CvCmpFunc = _rpythonic_function_(		"CvCmpFunc", ctypes.c_int, [
	("a",		ctypes.POINTER(ctypes.c_void_p)),
	("b",		ctypes.POINTER(ctypes.c_void_p)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvFillPoly = _rpythonic_function_(		"cvFillPoly", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("pts",		ctypes.POINTER(ctypes.POINTER(CvPoint))),
	("npts",		ctypes.POINTER(ctypes.c_int)),
	("contours",		ctypes.c_int),
	("color",		CvScalar),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvFillConvexPoly = _rpythonic_function_(		"cvFillConvexPoly", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("pts",		ctypes.POINTER(CvPoint)),
	("npts",		ctypes.c_int),
	("color",		CvScalar),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvPolyLine = _rpythonic_function_(		"cvPolyLine", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("pts",		ctypes.POINTER(ctypes.POINTER(CvPoint))),
	("npts",		ctypes.POINTER(ctypes.c_int)),
	("contours",		ctypes.c_int),
	("is_closed",		ctypes.c_int),
	("color",		CvScalar),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvSeqSort = _rpythonic_function_(		"cvSeqSort", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),
	("func",		ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSeqSearch = _rpythonic_function_(		"cvSeqSearch", ctypes.POINTER(ctypes.c_char), [
	("seq",		ctypes.POINTER(CvSeq)),
	("elem",		ctypes.POINTER(ctypes.c_void_p)),
	("func",		ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),)),
	("is_sorted",		ctypes.c_int),
	("elem_idx",		ctypes.POINTER(ctypes.c_int)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSeqInvert = _rpythonic_function_(		"cvSeqInvert", ctypes.c_void_p, [
	("seq",		ctypes.POINTER(CvSeq)),] )

cvSeqPartition = _rpythonic_function_(		"cvSeqPartition", ctypes.c_int, [
	("seq",		ctypes.POINTER(CvSeq)),
	("storage",		ctypes.POINTER(CvMemStorage)),
	("labels",		ctypes.POINTER(ctypes.POINTER(CvSeq))),
	("is_equal",		ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvChangeSeqBlock = _rpythonic_function_(		"cvChangeSeqBlock", ctypes.c_void_p, [
	("reader",		ctypes.POINTER(ctypes.c_void_p)),
	("direction",		ctypes.c_int),] )

cvCreateSeqBlock = _rpythonic_function_(		"cvCreateSeqBlock", ctypes.c_void_p, [
	("writer",		ctypes.POINTER(CvSeqWriter)),] )

cvCreateSet = _rpythonic_function_(		"cvCreateSet", ctypes.POINTER(CvSet), [
	("set_flags",		ctypes.c_int),
	("header_size",		ctypes.c_int),
	("elem_size",		ctypes.c_int),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvClipLine = _rpythonic_function_(		"cvClipLine", ctypes.c_int, [
	("img_size",		CvSize),
	("pt1",		ctypes.POINTER(CvPoint)),
	("pt2",		ctypes.POINTER(CvPoint)),] )

cvInitLineIterator = _rpythonic_function_(		"cvInitLineIterator", ctypes.c_int, [
	("image",		ctypes.POINTER(ctypes.c_void_p)),
	("pt1",		CvPoint),
	("pt2",		CvPoint),
	("line_iterator",		ctypes.POINTER(CvLineIterator)),
	("connectivity",		ctypes.c_int),
	("left_to_right",		ctypes.c_int),] )

cvInitFont = _rpythonic_function_(		"cvInitFont", ctypes.c_void_p, [
	("font",		ctypes.POINTER(CvFont)),
	("font_face",		ctypes.c_int),
	("hscale",		ctypes.c_double),
	("vscale",		ctypes.c_double),
	("shear",		ctypes.c_double),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),] )

cvGraphRemoveEdge = _rpythonic_function_(		"cvGraphRemoveEdge", ctypes.c_void_p, [
	("graph",		ctypes.POINTER(CvGraph)),
	("start_idx",		ctypes.c_int),
	("end_idx",		ctypes.c_int),] )

cvGraphRemoveEdgeByPtr = _rpythonic_function_(		"cvGraphRemoveEdgeByPtr", ctypes.c_void_p, [
	("graph",		ctypes.POINTER(CvGraph)),
	("start_vtx",		ctypes.POINTER(CvGraphVtx)),
	("end_vtx",		ctypes.POINTER(CvGraphVtx)),] )

cvFindGraphEdge = _rpythonic_function_(		"cvFindGraphEdge", ctypes.POINTER(CvGraphEdge), [
	("graph",		ctypes.POINTER(CvGraph)),
	("start_idx",		ctypes.c_int),
	("end_idx",		ctypes.c_int),] )

cvFindGraphEdgeByPtr = _rpythonic_function_(		"cvFindGraphEdgeByPtr", ctypes.POINTER(CvGraphEdge), [
	("graph",		ctypes.POINTER(CvGraph)),
	("start_vtx",		ctypes.POINTER(CvGraphVtx)),
	("end_vtx",		ctypes.POINTER(CvGraphVtx)),] )

cvClearGraph = _rpythonic_function_(		"cvClearGraph", ctypes.c_void_p, [
	("graph",		ctypes.POINTER(CvGraph)),] )

cvGraphVtxDegree = _rpythonic_function_(		"cvGraphVtxDegree", ctypes.c_int, [
	("graph",		ctypes.POINTER(CvGraph)),
	("vtx_idx",		ctypes.c_int),] )

cvGraphVtxDegreeByPtr = _rpythonic_function_(		"cvGraphVtxDegreeByPtr", ctypes.c_int, [
	("graph",		ctypes.POINTER(CvGraph)),
	("vtx",		ctypes.POINTER(CvGraphVtx)),] )

cvSetAdd = _rpythonic_function_(		"cvSetAdd", ctypes.c_int, [
	("set_header",		ctypes.POINTER(CvSet)),
	("elem",		ctypes.POINTER(CvSetElem)),
	("inserted_elem",		ctypes.POINTER(ctypes.POINTER(CvSetElem))),] )

cvSetRemove = _rpythonic_function_(		"cvSetRemove", ctypes.c_void_p, [
	("set_header",		ctypes.POINTER(CvSet)),
	("index",		ctypes.c_int),] )

cvClearSet = _rpythonic_function_(		"cvClearSet", ctypes.c_void_p, [
	("set_header",		ctypes.POINTER(CvSet)),] )

cvLUT = _rpythonic_function_(		"cvLUT", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("lut",		ctypes.POINTER(ctypes.c_void_p)),] )

cvInitTreeNodeIterator = _rpythonic_function_(		"cvInitTreeNodeIterator", ctypes.c_void_p, [
	("tree_iterator",		ctypes.POINTER(CvTreeNodeIterator)),
	("first",		ctypes.POINTER(ctypes.c_void_p)),
	("max_level",		ctypes.c_int),] )

cvNextTreeNode = _rpythonic_function_(		"cvNextTreeNode", ctypes.POINTER(ctypes.c_void_p), [
	("tree_iterator",		ctypes.POINTER(CvTreeNodeIterator)),] )

cvPrevTreeNode = _rpythonic_function_(		"cvPrevTreeNode", ctypes.POINTER(ctypes.c_void_p), [
	("tree_iterator",		ctypes.POINTER(CvTreeNodeIterator)),] )

cvInsertNodeIntoTree = _rpythonic_function_(		"cvInsertNodeIntoTree", ctypes.c_void_p, [
	("node",		ctypes.POINTER(ctypes.c_void_p)),
	("parent",		ctypes.POINTER(ctypes.c_void_p)),
	("frame",		ctypes.POINTER(ctypes.c_void_p)),] )

cvRemoveNodeFromTree = _rpythonic_function_(		"cvRemoveNodeFromTree", ctypes.c_void_p, [
	("node",		ctypes.POINTER(ctypes.c_void_p)),
	("frame",		ctypes.POINTER(ctypes.c_void_p)),] )

cvTreeToNodeSeq = _rpythonic_function_(		"cvTreeToNodeSeq", ctypes.POINTER(CvSeq), [
	("first",		ctypes.POINTER(ctypes.c_void_p)),
	("header_size",		ctypes.c_int),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvPutText = _rpythonic_function_(		"cvPutText", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("text",		ctypes.POINTER(ctypes.c_char)),
	("org",		CvPoint),
	("font",		ctypes.POINTER(CvFont)),
	("color",		CvScalar),] )

cvGetTextSize = _rpythonic_function_(		"cvGetTextSize", ctypes.c_void_p, [
	("text_string",		ctypes.POINTER(ctypes.c_char)),
	("font",		ctypes.POINTER(CvFont)),
	("text_size",		ctypes.POINTER(CvSize)),
	("baseline",		ctypes.POINTER(ctypes.c_int)),] )

cvColorToScalar = _rpythonic_function_(		"cvColorToScalar", CvScalar, [
	("packed_color",		ctypes.c_double),
	("arrtype",		ctypes.c_int),] )

cvEllipse2Poly = _rpythonic_function_(		"cvEllipse2Poly", ctypes.c_int, [
	("center",		CvPoint),
	("axes",		CvSize),
	("angle",		ctypes.c_int),
	("arc_start",		ctypes.c_int),
	("arc_end",		ctypes.c_int),
	("pts",		ctypes.POINTER(CvPoint)),
	("delta",		ctypes.c_int),] )

cvDrawContours = _rpythonic_function_(		"cvDrawContours", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("contour",		ctypes.POINTER(CvSeq)),
	("external_color",		CvScalar),
	("hole_color",		CvScalar),
	("max_level",		ctypes.c_int),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),
	("offset",		CvPoint),] )

cvCreateGraph = _rpythonic_function_(		"cvCreateGraph", ctypes.POINTER(CvGraph), [
	("graph_flags",		ctypes.c_int),
	("header_size",		ctypes.c_int),
	("vtx_size",		ctypes.c_int),
	("edge_size",		ctypes.c_int),
	("storage",		ctypes.POINTER(CvMemStorage)),] )

cvGraphAddVtx = _rpythonic_function_(		"cvGraphAddVtx", ctypes.c_int, [
	("graph",		ctypes.POINTER(CvGraph)),
	("vtx",		ctypes.POINTER(CvGraphVtx)),
	("inserted_vtx",		ctypes.POINTER(ctypes.POINTER(CvGraphVtx))),] )

cvGraphRemoveVtx = _rpythonic_function_(		"cvGraphRemoveVtx", ctypes.c_int, [
	("graph",		ctypes.POINTER(CvGraph)),
	("index",		ctypes.c_int),] )

cvGraphRemoveVtxByPtr = _rpythonic_function_(		"cvGraphRemoveVtxByPtr", ctypes.c_int, [
	("graph",		ctypes.POINTER(CvGraph)),
	("vtx",		ctypes.POINTER(CvGraphVtx)),] )

cvGraphAddEdge = _rpythonic_function_(		"cvGraphAddEdge", ctypes.c_int, [
	("graph",		ctypes.POINTER(CvGraph)),
	("start_idx",		ctypes.c_int),
	("end_idx",		ctypes.c_int),
	("edge",		ctypes.POINTER(CvGraphEdge)),
	("inserted_edge",		ctypes.POINTER(ctypes.POINTER(CvGraphEdge))),] )

cvGraphAddEdgeByPtr = _rpythonic_function_(		"cvGraphAddEdgeByPtr", ctypes.c_int, [
	("graph",		ctypes.POINTER(CvGraph)),
	("start_vtx",		ctypes.POINTER(CvGraphVtx)),
	("end_vtx",		ctypes.POINTER(CvGraphVtx)),
	("edge",		ctypes.POINTER(CvGraphEdge)),
	("inserted_edge",		ctypes.POINTER(ctypes.POINTER(CvGraphEdge))),] )

cvRectangleR = _rpythonic_function_(		"cvRectangleR", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("r",		CvRect),
	("color",		CvScalar),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvCircle = _rpythonic_function_(		"cvCircle", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("center",		CvPoint),
	("radius",		ctypes.c_int),
	("color",		CvScalar),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvEllipse = _rpythonic_function_(		"cvEllipse", ctypes.c_void_p, [
	("img",		ctypes.POINTER(ctypes.c_void_p)),
	("center",		CvPoint),
	("axes",		CvSize),
	("angle",		ctypes.c_double),
	("start_angle",		ctypes.c_double),
	("end_angle",		ctypes.c_double),
	("color",		CvScalar),
	("thickness",		ctypes.c_int),
	("line_type",		ctypes.c_int),
	("shift",		ctypes.c_int),] )

cvCheckTermCriteria = _rpythonic_function_(		"cvCheckTermCriteria", CvTermCriteria, [
	("criteria",		CvTermCriteria),
	("default_eps",		ctypes.c_double),
	("default_max_iters",		ctypes.c_int),] )

cvAdd = _rpythonic_function_(		"cvAdd", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvAddS = _rpythonic_function_(		"cvAddS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSub = _rpythonic_function_(		"cvSub", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvGet2D = _rpythonic_function_(		"cvGet2D", CvScalar, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),] )

cvGet1D = _rpythonic_function_(		"cvGet1D", CvScalar, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),] )

cvPtrND = _rpythonic_function_(		"cvPtrND", ctypes.POINTER(ctypes.c_ubyte), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx",		ctypes.POINTER(ctypes.c_int)),
	("C_type",		ctypes.POINTER(ctypes.c_int)),
	("create_node",		ctypes.c_int),
	("precalc_hashval",		ctypes.POINTER(ctypes.c_void_p)),] )

cvPtr3D = _rpythonic_function_(		"cvPtr3D", ctypes.POINTER(ctypes.c_ubyte), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("idx2",		ctypes.c_int),
	("C_type",		ctypes.POINTER(ctypes.c_int)),] )

cvPtr2D = _rpythonic_function_(		"cvPtr2D", ctypes.POINTER(ctypes.c_ubyte), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("C_type",		ctypes.POINTER(ctypes.c_int)),] )

cvPtr1D = _rpythonic_function_(		"cvPtr1D", ctypes.POINTER(ctypes.c_ubyte), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("C_type",		ctypes.POINTER(ctypes.c_int)),] )

cvReleaseSparseMat = _rpythonic_function_(		"cvReleaseSparseMat", ctypes.c_void_p, [
	("mat",		ctypes.POINTER(ctypes.POINTER(CvSparseMat))),] )

cvCloneSparseMat = _rpythonic_function_(		"cvCloneSparseMat", ctypes.POINTER(CvSparseMat), [
	("mat",		ctypes.POINTER(CvSparseMat)),] )

cvInitSparseMatIterator = _rpythonic_function_(		"cvInitSparseMatIterator", ctypes.POINTER(CvSparseNode), [
	("mat",		ctypes.POINTER(CvSparseMat)),
	("mat_iterator",		ctypes.POINTER(CvSparseMatIterator)),] )

cvCloneMatND = _rpythonic_function_(		"cvCloneMatND", ctypes.POINTER(CvMatND), [
	("mat",		ctypes.POINTER(CvMatND)),] )

cvInitMatNDHeader = _rpythonic_function_(		"cvInitMatNDHeader", ctypes.POINTER(CvMatND), [
	("mat",		ctypes.POINTER(CvMatND)),
	("dims",		ctypes.c_int),
	("sizes",		ctypes.POINTER(ctypes.c_int)),
	("C_type",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_void_p)),] )

cvCreateSparseMat = _rpythonic_function_(		"cvCreateSparseMat", ctypes.POINTER(CvSparseMat), [
	("dims",		ctypes.c_int),
	("sizes",		ctypes.POINTER(ctypes.c_int)),
	("C_type",		ctypes.c_int),] )

cvGetDimSize = _rpythonic_function_(		"cvGetDimSize", ctypes.c_int, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("index",		ctypes.c_int),] )

cvGetDims = _rpythonic_function_(		"cvGetDims", ctypes.c_int, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("sizes",		ctypes.POINTER(ctypes.c_int)),] )

cvGetElemType = _rpythonic_function_(		"cvGetElemType", ctypes.c_int, [("arr",		ctypes.c_void_p)] )

cvNextNArraySlice = _rpythonic_function_(		"cvNextNArraySlice", ctypes.c_int, [
	("array_iterator",		ctypes.POINTER(CvNArrayIterator)),] )

cvInitNArrayIterator = _rpythonic_function_(		"cvInitNArrayIterator", ctypes.c_int, [
	("count",		ctypes.c_int),
	("arrs",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),
	("stubs",		ctypes.POINTER(CvMatND)),
	("array_iterator",		ctypes.POINTER(CvNArrayIterator)),
	("flags",		ctypes.c_int),] )

cvSet1D = _rpythonic_function_(		"cvSet1D", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("value",		CvScalar),] )

cvGetRealND = _rpythonic_function_(		"cvGetRealND", ctypes.c_double, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx",		ctypes.POINTER(ctypes.c_int)),] )

cvGetReal3D = _rpythonic_function_(		"cvGetReal3D", ctypes.c_double, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("idx2",		ctypes.c_int),] )

cvGetReal2D = _rpythonic_function_(		"cvGetReal2D", ctypes.c_double, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),] )

cvGetReal1D = _rpythonic_function_(		"cvGetReal1D", ctypes.c_double, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),] )

cvGetND = _rpythonic_function_(		"cvGetND", CvScalar, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx",		ctypes.POINTER(ctypes.c_int)),] )

cvGet3D = _rpythonic_function_(		"cvGet3D", CvScalar, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("idx2",		ctypes.c_int),] )

cvClearND = _rpythonic_function_(		"cvClearND", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx",		ctypes.POINTER(ctypes.c_int)),] )

cvGetMat = _rpythonic_function_(		"cvGetMat", ctypes.POINTER(CvMat), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("header",		ctypes.POINTER(CvMat)),
	("coi",		ctypes.POINTER(ctypes.c_int)),
	("allowND",		ctypes.c_int),] )

cvGetImage = _rpythonic_function_(		"cvGetImage", ctypes.POINTER(_IplImage), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("image_header",		ctypes.POINTER(_IplImage)),] )

cvReshapeMatND = _rpythonic_function_(		"cvReshapeMatND", ctypes.POINTER(ctypes.c_void_p), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("sizeof_header",		ctypes.c_int),
	("header",		ctypes.POINTER(ctypes.c_void_p)),
	("new_cn",		ctypes.c_int),
	("new_dims",		ctypes.c_int),
	("new_sizes",		ctypes.POINTER(ctypes.c_int)),] )

cvReshape = _rpythonic_function_(		"cvReshape", ctypes.POINTER(CvMat), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("header",		ctypes.POINTER(CvMat)),
	("new_cn",		ctypes.c_int),
	("new_rows",		ctypes.c_int),] )

cvRepeat = _rpythonic_function_(		"cvRepeat", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSplit = _rpythonic_function_(		"cvSplit", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst0",		ctypes.POINTER(ctypes.c_void_p)),
	("dst1",		ctypes.POINTER(ctypes.c_void_p)),
	("dst2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst3",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMerge = _rpythonic_function_(		"cvMerge", ctypes.c_void_p, [
	("src0",		ctypes.POINTER(ctypes.c_void_p)),
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("src3",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMixChannels = _rpythonic_function_(		"cvMixChannels", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("src_count",		ctypes.c_int),
	("dst",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),
	("dst_count",		ctypes.c_int),
	("from_to",		ctypes.POINTER(ctypes.c_int)),
	("pair_count",		ctypes.c_int),] )

cvConvertScale = _rpythonic_function_(		"cvConvertScale", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("scale",		ctypes.c_double),
	("shift",		ctypes.c_double),] )

cvConvertScaleAbs = _rpythonic_function_(		"cvConvertScaleAbs", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("scale",		ctypes.c_double),
	("shift",		ctypes.c_double),] )

cvCreateData = _rpythonic_function_(		"cvCreateData", ctypes.c_void_p, [("arr",		ctypes.c_void_p)] )

cvReleaseData = _rpythonic_function_(		"cvReleaseData", ctypes.c_void_p, [("arr",		ctypes.c_void_p)] )

cvSetData = _rpythonic_function_(		"cvSetData", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("step",		ctypes.c_int),] )

cvGetRawData = _rpythonic_function_(		"cvGetRawData", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("data",		ctypes.POINTER(ctypes.POINTER(ctypes.c_ubyte))),
	("step",		ctypes.POINTER(ctypes.c_int)),
	("roi_size",		ctypes.POINTER(CvSize)),] )

cvGetSize = _rpythonic_function_(		"cvGetSize", CvSize, [("arr",		ctypes.c_void_p)] )

cvCopy = _rpythonic_function_(		"cvCopy", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSet = _rpythonic_function_(		"cvSet", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSetZero = _rpythonic_function_(		"cvSetZero", ctypes.c_void_p, [("arr",		ctypes.c_void_p)] )

cvScalarToRawData = _rpythonic_function_(		"cvScalarToRawData", ctypes.c_void_p, [
	("scalar",		ctypes.POINTER(CvScalar)),
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("C_type",		ctypes.c_int),
	("extend_to_12",		ctypes.c_int),] )

cvGetDiag = _rpythonic_function_(		"cvGetDiag", ctypes.POINTER(CvMat), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("submat",		ctypes.POINTER(CvMat)),
	("diag",		ctypes.c_int),] )

cvRawDataToScalar = _rpythonic_function_(		"cvRawDataToScalar", ctypes.c_void_p, [
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("C_type",		ctypes.c_int),
	("scalar",		ctypes.POINTER(CvScalar)),] )

cvCreateMatND = _rpythonic_function_(		"cvCreateMatND", ctypes.POINTER(CvMatND), [
	("dims",		ctypes.c_int),
	("sizes",		ctypes.POINTER(ctypes.c_int)),
	("C_type",		ctypes.c_int),] )

cvCreateMatNDHeader = _rpythonic_function_(		"cvCreateMatNDHeader", ctypes.POINTER(CvMatND), [
	("dims",		ctypes.c_int),
	("sizes",		ctypes.POINTER(ctypes.c_int)),
	("C_type",		ctypes.c_int),] )

cvSetRealND = _rpythonic_function_(		"cvSetRealND", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx",		ctypes.POINTER(ctypes.c_int)),
	("value",		ctypes.c_double),] )

cvSetReal3D = _rpythonic_function_(		"cvSetReal3D", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("idx2",		ctypes.c_int),
	("value",		ctypes.c_double),] )

cvSetReal2D = _rpythonic_function_(		"cvSetReal2D", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("value",		ctypes.c_double),] )

cvSetReal1D = _rpythonic_function_(		"cvSetReal1D", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("value",		ctypes.c_double),] )

cvSet3D = _rpythonic_function_(		"cvSet3D", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("idx2",		ctypes.c_int),
	("value",		CvScalar),] )

cvSetND = _rpythonic_function_(		"cvSetND", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx",		ctypes.POINTER(ctypes.c_int)),
	("value",		CvScalar),] )

cvSet2D = _rpythonic_function_(		"cvSet2D", ctypes.c_void_p, [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("idx0",		ctypes.c_int),
	("idx1",		ctypes.c_int),
	("value",		CvScalar),] )

cvAnd = _rpythonic_function_(		"cvAnd", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvAndS = _rpythonic_function_(		"cvAndS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvOr = _rpythonic_function_(		"cvOr", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvOrS = _rpythonic_function_(		"cvOrS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvXor = _rpythonic_function_(		"cvXor", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvXorS = _rpythonic_function_(		"cvXorS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSubRS = _rpythonic_function_(		"cvSubRS", ctypes.c_void_p, [
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("value",		CvScalar),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("mask",		ctypes.POINTER(ctypes.c_void_p)),] )

cvMul = _rpythonic_function_(		"cvMul", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("scale",		ctypes.c_double),] )

cvDiv = _rpythonic_function_(		"cvDiv", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("scale",		ctypes.c_double),] )

cvScaleAdd = _rpythonic_function_(		"cvScaleAdd", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("scale",		CvScalar),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvAddWeighted = _rpythonic_function_(		"cvAddWeighted", ctypes.c_void_p, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("alpha",		ctypes.c_double),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),
	("beta",		ctypes.c_double),
	("gamma",		ctypes.c_double),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),] )

cvDotProduct = _rpythonic_function_(		"cvDotProduct", ctypes.c_double, [
	("src1",		ctypes.POINTER(ctypes.c_void_p)),
	("src2",		ctypes.POINTER(ctypes.c_void_p)),] )

cvGetNumThreads = _rpythonic_function_(		"cvGetNumThreads", ctypes.c_int, [] )

cvSetNumThreads = _rpythonic_function_(		"cvSetNumThreads", ctypes.c_void_p, [
	("threads",		ctypes.c_int),] )

cvGetThreadNum = _rpythonic_function_(		"cvGetThreadNum", ctypes.c_int, [] )

cvCheckHardwareSupport = _rpythonic_function_(		"cvCheckHardwareSupport", ctypes.c_int, [
	("feature",		ctypes.c_int),] )

cvGetTickFrequency = _rpythonic_function_(		"cvGetTickFrequency", ctypes.c_double, [] )

cvLoad = _rpythonic_function_(		"cvLoad", ctypes.POINTER(ctypes.c_void_p), [
	("filename",		ctypes.POINTER(ctypes.c_char)),
	("memstorage",		ctypes.POINTER(CvMemStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("real_name",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),] )

cvTypeOf = _rpythonic_function_(		"cvTypeOf", ctypes.POINTER(CvTypeInfo), [("struct_ptr",		ctypes.c_void_p)] )

cvSave = _rpythonic_function_(		"cvSave", ctypes.c_void_p, [
	("filename",		ctypes.POINTER(ctypes.c_char)),
	("struct_ptr",		ctypes.POINTER(ctypes.c_void_p)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("comment",		ctypes.POINTER(ctypes.c_char)),
	("attributes",		CvAttrList),] )

cvClone = _rpythonic_function_(		"cvClone", ctypes.POINTER(ctypes.c_void_p), [("struct_ptr",		ctypes.c_void_p)] )

cvRelease = _rpythonic_function_(		"cvRelease", ctypes.c_void_p, [("struct_ptr",		ctypes.c_void_p)] )

cvGetTickCount = _rpythonic_function_(		"cvGetTickCount", ctypes.c_int64, [] )

cvReadRawDataSlice = _rpythonic_function_(		"cvReadRawDataSlice", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("reader",		ctypes.POINTER(CvSeqReader)),
	("count",		ctypes.c_int),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("dt",		ctypes.POINTER(ctypes.c_char)),] )

cvReadRawData = _rpythonic_function_(		"cvReadRawData", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("src",		ctypes.POINTER(CvFileNode)),
	("dst",		ctypes.POINTER(ctypes.c_void_p)),
	("dt",		ctypes.POINTER(ctypes.c_char)),] )

cvWriteFileNode = _rpythonic_function_(		"cvWriteFileNode", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("new_node_name",		ctypes.POINTER(ctypes.c_char)),
	("node",		ctypes.POINTER(CvFileNode)),
	("embed",		ctypes.c_int),] )

cvGetFileNodeName = _rpythonic_function_(		"cvGetFileNodeName", ctypes.POINTER(ctypes.c_char), [
	("node",		ctypes.POINTER(CvFileNode)),] )

cvRegisterType = _rpythonic_function_(		"cvRegisterType", ctypes.c_void_p, [
	("info",		ctypes.POINTER(CvTypeInfo)),] )

cvUnregisterType = _rpythonic_function_(		"cvUnregisterType", ctypes.c_void_p, [
	("type_name",		ctypes.POINTER(ctypes.c_char)),] )

cvFirstType = _rpythonic_function_(		"cvFirstType", ctypes.POINTER(CvTypeInfo), [] )

cvFindType = _rpythonic_function_(		"cvFindType", ctypes.POINTER(CvTypeInfo), [
	("type_name",		ctypes.POINTER(ctypes.c_char)),] )

cvNulDevReport = _rpythonic_function_(		"cvNulDevReport", ctypes.c_int, [
	("status",		ctypes.c_int),
	("func_name",		ctypes.POINTER(ctypes.c_char)),
	("err_msg",		ctypes.POINTER(ctypes.c_char)),
	("file_name",		ctypes.POINTER(ctypes.c_char)),
	("line",		ctypes.c_int),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvStdErrReport = _rpythonic_function_(		"cvStdErrReport", ctypes.c_int, [
	("status",		ctypes.c_int),
	("func_name",		ctypes.POINTER(ctypes.c_char)),
	("err_msg",		ctypes.POINTER(ctypes.c_char)),
	("file_name",		ctypes.POINTER(ctypes.c_char)),
	("line",		ctypes.c_int),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvGuiBoxReport = _rpythonic_function_(		"cvGuiBoxReport", ctypes.c_int, [
	("status",		ctypes.c_int),
	("func_name",		ctypes.POINTER(ctypes.c_char)),
	("err_msg",		ctypes.POINTER(ctypes.c_char)),
	("file_name",		ctypes.POINTER(ctypes.c_char)),
	("line",		ctypes.c_int),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

CvAllocFunc = _rpythonic_function_(		"CvAllocFunc", ctypes.POINTER(ctypes.c_void_p), [
	("size",		ctypes.c_size_t),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

CvFreeFunc = _rpythonic_function_(		"CvFreeFunc", ctypes.c_int, [
	("pptr",		ctypes.POINTER(ctypes.c_void_p)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

Cv_iplCloneImage = _rpythonic_function_(		"Cv_iplCloneImage", ctypes.POINTER(_IplImage), [
	("none",		ctypes.POINTER(ctypes.c_void_p)),] )

cvSetIPLAllocators = _rpythonic_function_(		"cvSetIPLAllocators", ctypes.c_void_p, [
	("create_header",		ctypes.POINTER(ctypes.CFUNCTYPE(ctypes.POINTER(_IplImage), ctypes.c_int,ctypes.c_int,ctypes.c_int,ctypes.POINTER(ctypes.c_char),ctypes.POINTER(ctypes.c_char),ctypes.c_int,ctypes.c_int,ctypes.c_int,ctypes.c_int,ctypes.c_int,ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),))),
	("allocate_data",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p),ctypes.c_int,ctypes.c_int,)),
	("deallocate",		ctypes.CFUNCTYPE(ctypes.c_void_p, ctypes.POINTER(ctypes.c_void_p),ctypes.c_int,)),
	("create_roi",		ctypes.POINTER(ctypes.CFUNCTYPE(ctypes.POINTER(_IplROI), ctypes.c_int,ctypes.c_int,ctypes.c_int,ctypes.c_int,ctypes.c_int,))),
	("clone_image",		ctypes.POINTER(ctypes.CFUNCTYPE(ctypes.POINTER(_IplImage), ctypes.POINTER(ctypes.c_void_p),))),] )

cvOpenFileStorage = _rpythonic_function_(		"cvOpenFileStorage", ctypes.POINTER(CvFileStorage), [
	("filename",		ctypes.POINTER(ctypes.c_char)),
	("memstorage",		ctypes.POINTER(CvMemStorage)),
	("flags",		ctypes.c_int),] )

cvReleaseFileStorage = _rpythonic_function_(		"cvReleaseFileStorage", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(ctypes.POINTER(CvFileStorage))),] )

cvAttrValue = _rpythonic_function_(		"cvAttrValue", ctypes.POINTER(ctypes.c_char), [
	("attr",		ctypes.POINTER(CvAttrList)),
	("attr_name",		ctypes.POINTER(ctypes.c_char)),] )

cvStartWriteStruct = _rpythonic_function_(		"cvStartWriteStruct", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("struct_flags",		ctypes.c_int),
	("type_name",		ctypes.POINTER(ctypes.c_char)),
	("attributes",		CvAttrList),] )

cvEndWriteStruct = _rpythonic_function_(		"cvEndWriteStruct", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),] )

cvWriteInt = _rpythonic_function_(		"cvWriteInt", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("value",		ctypes.c_int),] )

cvGetHashedKey = _rpythonic_function_(		"cvGetHashedKey", ctypes.POINTER(CvStringHashNode), [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("C_len",		ctypes.c_int),
	("create_missing",		ctypes.c_int),] )

cvGetRootFileNode = _rpythonic_function_(		"cvGetRootFileNode", ctypes.POINTER(CvFileNode), [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("stream_index",		ctypes.c_int),] )

cvGetFileNode = _rpythonic_function_(		"cvGetFileNode", ctypes.POINTER(CvFileNode), [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("map",		ctypes.POINTER(CvFileNode)),
	("key",		ctypes.POINTER(CvStringHashNode)),
	("create_missing",		ctypes.c_int),] )

cvGetFileNodeByName = _rpythonic_function_(		"cvGetFileNodeByName", ctypes.POINTER(CvFileNode), [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("map",		ctypes.POINTER(CvFileNode)),
	("name",		ctypes.POINTER(ctypes.c_char)),] )

cvWriteReal = _rpythonic_function_(		"cvWriteReal", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("value",		ctypes.c_double),] )

cvWriteString = _rpythonic_function_(		"cvWriteString", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("C_str",		ctypes.POINTER(ctypes.c_char)),
	("quote",		ctypes.c_int),] )

cvWriteComment = _rpythonic_function_(		"cvWriteComment", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("comment",		ctypes.POINTER(ctypes.c_char)),
	("eol_comment",		ctypes.c_int),] )

cvWrite = _rpythonic_function_(		"cvWrite", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("ptr",		ctypes.POINTER(ctypes.c_void_p)),
	("attributes",		CvAttrList),] )

cvStartNextStream = _rpythonic_function_(		"cvStartNextStream", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),] )

cvWriteRawData = _rpythonic_function_(		"cvWriteRawData", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("src",		ctypes.POINTER(ctypes.c_void_p)),
	("C_len",		ctypes.c_int),
	("dt",		ctypes.POINTER(ctypes.c_char)),] )

cvSetMemoryManager = _rpythonic_function_(		"cvSetMemoryManager", ctypes.c_void_p, [
	("alloc_func",		ctypes.POINTER(ctypes.CFUNCTYPE(ctypes.POINTER(ctypes.c_void_p), ctypes.c_size_t,ctypes.POINTER(ctypes.c_void_p),))),
	("free_func",		ctypes.CFUNCTYPE(ctypes.c_int, ctypes.POINTER(ctypes.c_void_p),ctypes.POINTER(ctypes.c_void_p),)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

Cv_iplCreateImageHeader = _rpythonic_function_(		"Cv_iplCreateImageHeader", ctypes.POINTER(_IplImage), [
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.POINTER(ctypes.c_char)),
	("none",		ctypes.POINTER(ctypes.c_char)),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.POINTER(ctypes.c_void_p)),] )

Cv_iplAllocateImageData = _rpythonic_function_(		"Cv_iplAllocateImageData", ctypes.c_void_p, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),] )

Cv_iplDeallocate = _rpythonic_function_(		"Cv_iplDeallocate", ctypes.c_void_p, [
	("none",		ctypes.POINTER(ctypes.c_void_p)),
	("none",		ctypes.c_int),] )

Cv_iplCreateROI = _rpythonic_function_(		"Cv_iplCreateROI", ctypes.POINTER(_IplROI), [
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),
	("none",		ctypes.c_int),] )

cvRead = _rpythonic_function_(		"cvRead", ctypes.POINTER(ctypes.c_void_p), [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("node",		ctypes.POINTER(CvFileNode)),
	("attributes",		ctypes.POINTER(CvAttrList)),] )

cvStartReadRawData = _rpythonic_function_(		"cvStartReadRawData", ctypes.c_void_p, [
	("fs",		ctypes.POINTER(CvFileStorage)),
	("src",		ctypes.POINTER(CvFileNode)),
	("reader",		ctypes.POINTER(CvSeqReader)),] )

cvSetErrMode = _rpythonic_function_(		"cvSetErrMode", ctypes.c_int, [
	("mode",		ctypes.c_int),] )

cvError = _rpythonic_function_(		"cvError", ctypes.c_void_p, [
	("status",		ctypes.c_int),
	("func_name",		ctypes.POINTER(ctypes.c_char)),
	("err_msg",		ctypes.POINTER(ctypes.c_char)),
	("file_name",		ctypes.POINTER(ctypes.c_char)),
	("line",		ctypes.c_int),] )

cvErrorStr = _rpythonic_function_(		"cvErrorStr", ctypes.POINTER(ctypes.c_char), [
	("status",		ctypes.c_int),] )

cvGetErrInfo = _rpythonic_function_(		"cvGetErrInfo", ctypes.c_int, [
	("errcode_desc",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("description",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("filename",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("line",		ctypes.POINTER(ctypes.c_int)),] )

cvErrorFromIppStatus = _rpythonic_function_(		"cvErrorFromIppStatus", ctypes.c_int, [
	("ipp_status",		ctypes.c_int),] )

CvErrorCallback = _rpythonic_function_(		"CvErrorCallback", ctypes.c_int, [
	("status",		ctypes.c_int),
	("func_name",		ctypes.POINTER(ctypes.c_char)),
	("err_msg",		ctypes.POINTER(ctypes.c_char)),
	("file_name",		ctypes.POINTER(ctypes.c_char)),
	("line",		ctypes.c_int),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),] )

cvRedirectError = _rpythonic_function_(		"cvRedirectError", ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int,ctypes.POINTER(ctypes.c_char),ctypes.POINTER(ctypes.c_char),ctypes.POINTER(ctypes.c_char),ctypes.c_int,ctypes.POINTER(ctypes.c_void_p),), [
	("error_handler",		ctypes.CFUNCTYPE(ctypes.c_int, ctypes.c_int,ctypes.POINTER(ctypes.c_char),ctypes.POINTER(ctypes.c_char),ctypes.POINTER(ctypes.c_char),ctypes.c_int,ctypes.POINTER(ctypes.c_void_p),)),
	("userdata",		ctypes.POINTER(ctypes.c_void_p)),
	("prev_userdata",		ctypes.POINTER(ctypes.POINTER(ctypes.c_void_p))),] )

cvKMeans2 = _rpythonic_function_(		"cvKMeans2", ctypes.c_int, [
	("samples",		ctypes.POINTER(ctypes.c_void_p)),
	("cluster_count",		ctypes.c_int),
	("labels",		ctypes.POINTER(ctypes.c_void_p)),
	("termcrit",		CvTermCriteria),
	("attempts",		ctypes.c_int),
	("rng",		ctypes.POINTER(ctypes.c_uint64)),
	("flags",		ctypes.c_int),
	("_centers",		ctypes.POINTER(ctypes.c_void_p)),
	("compactness",		ctypes.POINTER(ctypes.c_double)),] )

cvRegisterModule = _rpythonic_function_(		"cvRegisterModule", ctypes.c_int, [
	("module_info",		ctypes.POINTER(CvModuleInfo)),] )

cvUseOptimized = _rpythonic_function_(		"cvUseOptimized", ctypes.c_int, [
	("on_off",		ctypes.c_int),] )

cvGetModuleInfo = _rpythonic_function_(		"cvGetModuleInfo", ctypes.c_void_p, [
	("module_name",		ctypes.POINTER(ctypes.c_char)),
	("version",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("loaded_addon_plugins",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),] )

cvGetErrStatus = _rpythonic_function_(		"cvGetErrStatus", ctypes.c_int, [] )

cvSetErrStatus = _rpythonic_function_(		"cvSetErrStatus", ctypes.c_void_p, [
	("status",		ctypes.c_int),] )

cvGetErrMode = _rpythonic_function_(		"cvGetErrMode", ctypes.c_int, [] )

CvIsInstanceFunc = _rpythonic_function_(		"CvIsInstanceFunc", ctypes.c_int, [("struct_ptr",		ctypes.c_void_p)] )

CvReleaseFunc = _rpythonic_function_(		"CvReleaseFunc", ctypes.c_void_p, [("struct_dblptr",		ctypes.c_void_p)] )

CvReadFunc = _rpythonic_function_(		"CvReadFunc", ctypes.POINTER(ctypes.c_void_p), [
	("storage",		ctypes.POINTER(CvFileStorage)),
	("node",		ctypes.POINTER(CvFileNode)),] )

CvWriteFunc = _rpythonic_function_(		"CvWriteFunc", ctypes.c_void_p, [
	("storage",		ctypes.POINTER(CvFileStorage)),
	("name",		ctypes.POINTER(ctypes.c_char)),
	("struct_ptr",		ctypes.POINTER(ctypes.c_void_p)),
	("attributes",		CvAttrList),] )

CvCloneFunc = _rpythonic_function_(		"CvCloneFunc", ctypes.POINTER(ctypes.c_void_p), [("struct_ptr",		ctypes.c_void_p)] )

cvCloneMat = _rpythonic_function_(		"cvCloneMat", ctypes.POINTER(CvMat), [
	("mat",		ctypes.POINTER(CvMat)),] )

cvGetSubRect = _rpythonic_function_(		"cvGetSubRect", ctypes.POINTER(CvMat), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("submat",		ctypes.POINTER(CvMat)),
	("rect",		CvRect),] )

cvGetRows = _rpythonic_function_(		"cvGetRows", ctypes.POINTER(CvMat), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("submat",		ctypes.POINTER(CvMat)),
	("start_row",		ctypes.c_int),
	("end_row",		ctypes.c_int),
	("delta_row",		ctypes.c_int),] )

cvGetCols = _rpythonic_function_(		"cvGetCols", ctypes.POINTER(CvMat), [
	("arr",		ctypes.POINTER(ctypes.c_void_p)),
	("submat",		ctypes.POINTER(CvMat)),
	("start_col",		ctypes.c_int),
	("end_col",		ctypes.c_int),] )

cvAlloc = _rpythonic_function_(		"cvAlloc", ctypes.POINTER(ctypes.c_void_p), [
	("size",		ctypes.c_size_t),] )

cvFree_ = _rpythonic_function_(		"cvFree_", ctypes.c_void_p, [("ptr",		ctypes.c_void_p)] )

cvCreateImageHeader = _rpythonic_function_(		"cvCreateImageHeader", ctypes.POINTER(_IplImage), [
	("size",		CvSize),
	("depth",		ctypes.c_int),
	("channels",		ctypes.c_int),] )

cvInitImageHeader = _rpythonic_function_(		"cvInitImageHeader", ctypes.POINTER(_IplImage), [
	("image",		ctypes.POINTER(_IplImage)),
	("size",		CvSize),
	("depth",		ctypes.c_int),
	("channels",		ctypes.c_int),
	("origin",		ctypes.c_int),
	("align",		ctypes.c_int),] )

cvCreateImage = _rpythonic_function_(		"cvCreateImage", ctypes.POINTER(_IplImage), [
	("size",		CvSize),
	("depth",		ctypes.c_int),
	("channels",		ctypes.c_int),] )

cvResetImageROI = _rpythonic_function_(		"cvResetImageROI", ctypes.c_void_p, [
	("image",		ctypes.POINTER(_IplImage)),] )

cvReleaseImageHeader = _rpythonic_function_(		"cvReleaseImageHeader", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.POINTER(_IplImage))),] )

cvReleaseImage = _rpythonic_function_(		"cvReleaseImage", ctypes.c_void_p, [
	("image",		ctypes.POINTER(ctypes.POINTER(_IplImage))),] )

cvCloneImage = _rpythonic_function_(		"cvCloneImage", ctypes.POINTER(_IplImage), [
	("image",		ctypes.POINTER(_IplImage)),] )

cvSetImageCOI = _rpythonic_function_(		"cvSetImageCOI", ctypes.c_void_p, [
	("image",		ctypes.POINTER(_IplImage)),
	("coi",		ctypes.c_int),] )

cvGetImageCOI = _rpythonic_function_(		"cvGetImageCOI", ctypes.c_int, [
	("image",		ctypes.POINTER(_IplImage)),] )

cvSetImageROI = _rpythonic_function_(		"cvSetImageROI", ctypes.c_void_p, [
	("image",		ctypes.POINTER(_IplImage)),
	("rect",		CvRect),] )

cvGetImageROI = _rpythonic_function_(		"cvGetImageROI", CvRect, [
	("image",		ctypes.POINTER(_IplImage)),] )

cvCreateMatHeader = _rpythonic_function_(		"cvCreateMatHeader", ctypes.POINTER(CvMat), [
	("rows",		ctypes.c_int),
	("cols",		ctypes.c_int),
	("C_type",		ctypes.c_int),] )

cvInitMatHeader = _rpythonic_function_(		"cvInitMatHeader", ctypes.POINTER(CvMat), [
	("mat",		ctypes.POINTER(CvMat)),
	("rows",		ctypes.c_int),
	("cols",		ctypes.c_int),
	("C_type",		ctypes.c_int),
	("data",		ctypes.POINTER(ctypes.c_void_p)),
	("step",		ctypes.c_int),] )

cvCreateMat = _rpythonic_function_(		"cvCreateMat", ctypes.POINTER(CvMat), [
	("rows",		ctypes.c_int),
	("cols",		ctypes.c_int),
	("C_type",		ctypes.c_int),] )

cvReleaseMat = _rpythonic_function_(		"cvReleaseMat", ctypes.c_void_p, [
	("mat",		ctypes.POINTER(ctypes.POINTER(CvMat))),] )


_rpythonic_convert_structs_to_objects()

IPL_DEPTH_1U = 1
IPL_DEPTH_8U = 8
IPL_DEPTH_16U = 16
IPL_DEPTH_32F = 32
IPL_DEPTH_SIGN = 0x80000000
IPL_DEPTH_8S = IPL_DEPTH_SIGN | 8
IPL_DEPTH_16S = IPL_DEPTH_SIGN | 16
IPL_DEPTH_32S = IPL_DEPTH_SIGN | 32

IPL_DATA_ORDER_PIXEL = 0
IPL_DATA_ORDER_PLANE = 1

IPL_ORIGIN_TL = 0
IPL_ORIGIN_BL = 1

IPL_ALIGN_4BYTES =  4
IPL_ALIGN_8BYTES =  8
IPL_ALIGN_16BYTES = 16
IPL_ALIGN_32BYTES = 32
IPL_ALIGN_DWORD =  IPL_ALIGN_4BYTES
IPL_ALIGN_QWORD =  IPL_ALIGN_8BYTES

IPL_GET_TILE_TO_READ =  1
IPL_GET_TILE_TO_WRITE = 2
IPL_RELEASE_TILE = 4

IPL_LUT_LOOKUP = 0
IPL_LUT_INTER = 1

CV_AA = 16
CV_WHOLE_SEQ = CvSlice(0,9999999)
cvConvert = lambda a,b: cvConvertScale( a, b, 1.0, 0.0 )

IplImage.CvtColor = lambda a, b, t: cvCvtColor(a, b, t )
IplImage.Convert = lambda a, b: cvConvertScale( a, b, 1.0, 0.0 )


_rpythonic_setup_return_wrappers()
_rpythonic_make_nice_global_enums_()
_rpythonic_clean_up_missing_functions_()

################### Raymond Hettinger's Constant Folding ##################
# Decorator for BindingConstants at compile time
# A recipe by Raymond Hettinger, from Python Cookbook:
# http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/277940
# updated for Python3 and still compatible with Python2 - by Hart, May17th 2011

try: _BUILTINS_DICT_ = vars(__builtins__)
except: _BUILTINS_DICT_ = __builtins__
ISPYTHON2 = sys.version_info[0] == 2
_HETTINGER_FOLDS_ = 0

def _hettinger_make_constants(f, builtin_only=False, stoplist=[], verbose=0):
    from opcode import opmap, HAVE_ARGUMENT, EXTENDED_ARG
    global _HETTINGER_FOLDS_
    try:
        if ISPYTHON2: co = f.func_code; fname = f.func_name
        else: co = f.__code__; fname = f.__name__
    except AttributeError: return f        # Jython doesn't have a func_code attribute.
    if ISPYTHON2: newcode = map(ord, co.co_code)
    else: newcode = list( co.co_code )
    newconsts = list(co.co_consts)
    names = co.co_names
    codelen = len(newcode)
    if ISPYTHON2:
        if verbose >= 2: print( f.func_name )
        func_globals = f.func_globals
    else:
        if verbose >= 2: print( f.__name__ )
        func_globals = f.__globals__

    env = _BUILTINS_DICT_.copy()
    if builtin_only:
        stoplist = dict.fromkeys(stoplist)
        stoplist.update(func_globals)
    else:
        env.update(func_globals)

    # First pass converts global lookups into constants
    i = 0
    while i < codelen:
        opcode = newcode[i]
        if opcode in (EXTENDED_ARG, opmap['STORE_GLOBAL']):
            if verbose >= 1: print('skipping function', fname)
            return f    # for simplicity, only optimize common cases
        if opcode == opmap['LOAD_GLOBAL']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = co.co_names[oparg]
            if name in env and name not in stoplist:
                value = env[name]
                for pos, v in enumerate(newconsts):
                    if v is value:
                        break
                else:
                    pos = len(newconsts)
                    newconsts.append(value)
                newcode[i] = opmap['LOAD_CONST']
                newcode[i+1] = pos & 0xFF
                newcode[i+2] = pos >> 8
                _HETTINGER_FOLDS_ += 1
                if verbose >= 2:
                    print( "    global constant fold:", name )
        i += 1
        if opcode >= HAVE_ARGUMENT:
            i += 2

    # Second pass folds tuples of constants and constant attribute lookups
    i = 0
    while i < codelen:

        newtuple = []
        while newcode[i] == opmap['LOAD_CONST']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            newtuple.append(newconsts[oparg])
            i += 3

        opcode = newcode[i]
        if not newtuple:
            i += 1
            if opcode >= HAVE_ARGUMENT:
                i += 2
            continue

        if opcode == opmap['LOAD_ATTR']:
            obj = newtuple[-1]
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            name = names[oparg]
            try:
                value = getattr(obj, name)
                if verbose >= 2: print( '    folding attribute', name )
            except AttributeError:
                continue
            deletions = 1

        elif opcode == opmap['BUILD_TUPLE']:
            oparg = newcode[i+1] + (newcode[i+2] << 8)
            if oparg != len(newtuple): continue
            deletions = len(newtuple)
            value = tuple(newtuple)

        else: continue

        reljump = deletions * 3
        newcode[i-reljump] = opmap['JUMP_FORWARD']
        newcode[i-reljump+1] = (reljump-3) & 0xFF
        newcode[i-reljump+2] = (reljump-3) >> 8

        n = len(newconsts)
        newconsts.append(value)
        newcode[i] = opmap['LOAD_CONST']
        newcode[i+1] = n & 0xFF
        newcode[i+2] = n >> 8
        i += 3
        _HETTINGER_FOLDS_ += 1
        if verbose >= 2:
            print( "    folded constant:",value )

    if ISPYTHON2:
        codestr = ''.join(map(chr, newcode))
        codeobj = type(co)(co.co_argcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.func_globals, f.func_name, f.func_defaults, f.func_closure)
    else:
        codestr = b''
        for s in newcode: codestr += s.to_bytes(1,'little')
        codeobj = type(co)(co.co_argcount, co.co_kwonlyargcount, co.co_nlocals, co.co_stacksize,
                        co.co_flags, codestr, tuple(newconsts), co.co_names,
                        co.co_varnames, co.co_filename, co.co_name,
                        co.co_firstlineno, co.co_lnotab, co.co_freevars,
                        co.co_cellvars)
        return type(f)(codeobj, f.__globals__, f.__name__, f.__defaults__, f.__closure__)


def hettinger_bind_recursive(mc, builtin_only=False, stoplist=[],  verbose=0):
    """Recursively apply constant binding to functions in a module or class.

    Use as the last line of the module (after everything is defined, but
    before test code).  In modules that need modifiable globals, set
    builtin_only to True.

    """
    import types
    try: d = vars(mc)
    except TypeError: return
    if ISPYTHON2: recursivetypes = (type, types.ClassType)
    else: recursivetypes = (type,)
    for k, v in d.items():
        if type(v) is types.FunctionType:
            newv = _hettinger_make_constants(v, builtin_only, stoplist,  verbose)
            setattr(mc, k, newv)
        elif type(v) in recursivetypes:
            hettinger_bind_recursive(v, builtin_only, stoplist, verbose)

def hettinger_transform( module=None ):
    global _HETTINGER_FOLDS_
    _HETTINGER_FOLDS_ = 0
    if not module: module = sys.modules[__name__]
    hettinger_bind_recursive( module, verbose=1 )
    print( 'HETTINGER: constants folded', _HETTINGER_FOLDS_ )

_rpythonic_strip_prefixes_(['cv'])