## generated by RPythonic 0.4.8h	| host: 64bits
## http://code.google.com/p/rpythonic/
import os, sys, ctypes, inspect
__os = os
__sys = sys
__inspect = inspect
_CTYPES_CDLLS = []	# support loading functions from multiple libraries


PYTHON_RESERVED_KEYWORDS = 'for while in as global with try except lambda return raise if else elif eval exec and not or break continue finally print yield del def class assert from is pass'.split()


IS32BIT = (ctypes.sizeof(ctypes.c_void_p)==4)

_ISPYTHON2 = sys.version_info[0] == 2
if _ISPYTHON2: _NULLBYTE = '\0'
else: _NULLBYTE = bytes( chr(0), 'ascii' )

def _CHARP2STRING( charp, encoding='utf-8' ):
	b = bytes()
	i = 0
	while True:
		char = charp[ i ]
		if char == _NULLBYTE: break
		else:
			b += char
			i += 1
	return b.decode( encoding )

## try to load precompiled c-libraries from this directory, if the library is not there try to load from the system.
_clibs_dir = os.path.dirname(os.path.abspath(__file__))

def _load_ctypes_lib( name ):
	if __os.name == 'posix':
		if __sys.platform.startswith('linux'):
			if not name.endswith('.so'): name += '.so'
			if not name.startswith('lib'): name = 'lib' + name

			if IS32BIT: 	path = __os.path.join(_clibs_dir,'linux32')
			else: 		path = __os.path.join(_clibs_dir,'linux64')
			url = __os.path.join( path, name )
			if __os.path.isfile( url ): return ctypes.CDLL(url)
			elif __os.path.isfile( '/usr/local/lib/%s'%name ): return ctypes.CDLL('/usr/local/lib/%s'%name)
			elif __os.path.isfile( '/usr/local/lib64/%s'%name ) and not IS32BIT: return ctypes.CDLL('/usr/local/lib64/%s'%name)
			elif __os.path.isfile( '/usr/lib/%s'%name ): return ctypes.CDLL('/usr/lib/%s'%name)
			elif __os.path.isfile( './%s'%name ): return ctypes.CDLL('./%s'%name)
			
			elif __os.path.isfile( '/usr/lib/%s.0'%name ):	# Fedora style
				return ctypes.CDLL('/usr/lib/%s.0'%name )
			elif __os.path.isfile( '/usr/lib64/%s.0'%name ):	# Fedora style
				return ctypes.CDLL('/usr/lib64/%s.0'%name )

			else:	# fallback
				print('[ falling back to loading from current process ]')
				try: return ctypes.CDLL(name)
				except: return ctypes.CDLL('')

		elif sys.platform == 'darwin':
			name += '.dylib'
			if IS32BIT: 	path = os.path.join(_clibs_dir,'osx32')
			else: 		path = os.path.join(_clibs_dir,'osx64')
			url = os.path.join( path, name )
			if os.path.isfile( url ): return ctypes.CDLL(url)
			else: return ctypes.CDLL(name) #fallback

	elif os.name == 'nt':
		name += '.dll'
		if IS32BIT: 	path = os.path.join(_clibs_dir,'win32')
		else: 		path = os.path.join(_clibs_dir,'win64')
		url = os.path.join( path, name )
		if os.path.isfile( url ): return ctypes.CDLL(url)
		else: return ctypes.CDLL(name) #fallback

RPYTHONIC_WRAPPER_FUNCTIONS = {}
RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES = []
RPYTHONIC_AUTOPREFIX_IGNORE = []

## ctypes does not clearly expose these types ##
PyCFuncPtrType = type(ctypes.CFUNCTYPE(ctypes.c_void_p))
PyCArrayType = type( ctypes.c_int * 2 )
PyCPointerType = type( ctypes.POINTER(ctypes.c_int) )
PyCStructType = type( ctypes.Structure )
CArgObject = type( ctypes.byref(ctypes.c_int()) )

class _rpythonic_meta_(object):
	'''
	Reserved Attributes:
		POINTER
		CSTRUCT
		CAST
	'''
	_rpythonic_ = True		# workaround for now, must have a way to know if object is a meta from another module, isinstance(o,_rpythonic_meta_) will fail in those cases. another workaround could be check sys.modules for other rpythonic modules and fetch _rpythonic_meta_ from there.
	def __init__(self, *args, **kw ):							# cheap trick, abuse **kw, and look for "pointer", "cast"
		if kw and 'pointer' not in kw: raise SyntaxError	# sorry, you can not init with keywords
		elif kw and 'pointer' in kw:
			if 'cast' in kw and kw['cast']:
				self.POINTER = ctypes.cast( kw['pointer'], ctypes.POINTER(self.CSTRUCT) )
			else: self.POINTER = kw['pointer']
		else: self.POINTER = ctypes.pointer( self.CSTRUCT(*args) )
		self.POINTER.pyobject = self	# .pyobject is local to this pointer "object"

	def __getattr__(self,name):
		if hasattr( self.POINTER.contents, name ):
			return getattr( self.POINTER.contents, name )

		else:	# when rpythonic failed to generate good bindings - these lookups should be cached
			for parent in self._rpythonic_parent_classes_:
				if hasattr( parent, name ):
					method = getattr( parent, name )	# should check if it really is an unbound method
					if method in parent._rpythonic_unbound_lookup_:
						func = parent._rpythonic_unbound_lookup_[ method ]
						n = func.name
						if len(func.argnames) > 1:
							argnames = func.argnames[ 1 : ]
							a = ',' + '=None,'.join( argnames ) + '=None'
							b = ','.join( argnames )
						else: a = b = ''
						lamb = eval( 'lambda self %s: %s( self.POINTER, %s )' %(a,n,b) )
						setattr( self.__class__, name, lamb )
						#return lamb	# this would return the unbound lambda, must call getattr again
						return getattr( self, name )
					else:
						# this can happen if self also inherits from the same parent class,
						# assume that by continuing this reaches that shared parent class,
						# and the lambda above is created as normal.
						continue
			## last resort, load from global name space ##
			G = globals()
			if name in G: return lambda *args: G[name](self.POINTER, *args)
			else:
				for prefix in self._autoprefix_:
					n = prefix + name
					if n in G: return lambda *args: G[n](self.POINTER, *args)
				print( 'possible auto-prefixes available', self._autoprefix_ )
				raise AttributeError

	def __call__(self, type=False):
		print('calling object is DEPRECATED - use ob.POINTER or ob.CSTRUCT')
		if type: return self.CSTRUCT
		else: return self.POINTER


def _rpythonic_generate_subclass_( name, struct, functions ):
	head = 'class %s( _rpythonic_meta_ ):' %name
	body = [ 
		'_rpythonic_parent_classes_ = []' ,
		'_rpythonic_unbound_lookup_ = {}' 
	]

	names = [ func.name for func in functions ]

	possibles = {}
	rank = []		# rank by longest name
	if len(names) > 3000: print('too many functions to use this hack')
	else:
		for n1 in names:
			prefix = ''
			for i,char in enumerate(n1):
				prefix += char
				if prefix not in possibles:
					possibles[ prefix ] = 0
					for n2 in names:
						if n2.startswith( prefix ):
							possibles[ prefix ] += 1

					if not rank or len(prefix) > len(rank[-1]) and possibles[prefix] > len(names)/4:
						rank.append( prefix )

	top = []
	while rank:
		best = rank.pop()
		if possibles[best] > len(functions)/2 and best not in names:
			if best.endswith('_set_') or best.endswith('_get_'): best = best[ : -4 ]
			elif best.endswith('Set') or best.endswith('Get'): best = best[ : -3 ]

			rem = []
			for other in rank:
				if best.startswith(other): rem.append( other )
			for r in rem: rank.remove( r )

			if best not in top: top.append( best )

		if len(top) > 3: break

	for n in names:		# find shortest prefixes #
		prefix = ''
		for i,char in enumerate(n):		# cammelCase
			if i==0: prefix += char; continue
			if char.isupper() and len(prefix) >= 2: break
			prefix += char
		if prefix and prefix != n and len(prefix) >= 2:
			hits = 0
			for other in names:
				if other.startswith( prefix ): hits += 1
			if hits >= 2 and prefix not in top:
				top.append( prefix )
				if len(top) >= 6: break

	## setup full names
	for func in functions:
		n = func.name
		if len(func.argnames) > 1:
			argnames = func.argnames[ 1 : ]
			a = ',' + '=None,'.join( argnames ) + '=None'
			b = ','.join( argnames )
		else: a = b = ''

		fhead = 'def %s( self %s ):' %(n,a)
		fbody = ['return %s(self.POINTER, %s)' %(func.name,b)]
		g = fhead + '\n\t\t' + '\n\t\t'.join( fbody )
		body.append( g )
		#body.append( '%s._rpythonic_function_ = %s' %(func.name, func.name) )

	## setup short names ##
	for n in names:
		for prefix in top:
			if n.startswith(prefix) and n[len(prefix):] not in names:
				alt = n[ len(prefix) : ]
				if alt and alt != n and alt not in PYTHON_RESERVED_KEYWORDS and not alt.isdigit() and not alt[0].isdigit():
					body.append( '%s = %s' %(alt,n) )
					names.append( alt )

	gen = head + '\n\t' + '\n\t'.join( body )
	try: exec( gen )
	except:
		print( gen )
		raise SyntaxError

	klass = locals()[name]
	klass.CSTRUCT = struct	# ctypes struct class

	klass._autoprefix_ = top
	for func in functions:
		unbound = getattr( klass, func.name )
		klass._rpythonic_unbound_lookup_[ unbound ] = func
		# klass.longname is klass.shortname = False
		# klass.longname == klass.shortname = True
	return klass

def _rpythonic_convert_structs_to_objects():
	G = globals()
	for klass in _OOAPI_:
		altname = name = klass.__name__
		prefix = ''
		for i,char in enumerate(name):
			if i==0: prefix += char; continue
			if char.isupper(): break
			prefix += char
		if prefix and prefix != name:
			hits = 0
			for other in _OOAPI_:
				if other is not klass:
					if other.__name__.startswith( prefix ): hits += 1
			if hits >= 2:
				altname = name[ len(prefix) : ]

		funcs = _OOAPI_[ klass ]
		newklass = _rpythonic_generate_subclass_( altname, klass, funcs )
		klass._rpythonic_wrapper_class_ = newklass
		G[ name ] = newklass	# replace struct with wrapper
		if altname not in G: G[ altname ] = newklass	# safely define with nicer name
		elif altname != name: # odd cases, maybe a function that returns the object, almost never happens.
			print('WARN - not replacing something with struct wrapper:', G[altname] )


def _rpythonic_setup_return_wrappers():
	R = _rpythonic_function_
	for klass in _OOAPI_:
		if klass in _OOAPI_RETURNS_OBJECT_:
			for f in _OOAPI_RETURNS_OBJECT_[klass]:
				f.object_oriented = True
				if not f.return_wrapper:	# just in case the ctypes footer had already defined it, do not overwrite
					f.return_wrapper = klass._rpythonic_wrapper_class_


###############################################################
##						OLD META FUNC						##
###############################################################
def _rpythonic_function_( name, result=ctypes.c_void_p, args=[]):
	mname = '_metafunc_%s' %name
	exec( 'class %s( _rpythonic_metafunc_ ): pass' %mname )
	k = locals()[mname]
	return k( name, result, args )
_OOAPI_ = {}
_OOAPI_RETURNS_OBJECT_ = {}
class _rpythonic_metafunc_(object):
	def __init__(self, name, result=ctypes.c_void_p, args=[]):
		self.name = name
		self.result = result
		self.argtypes = []		# can dynamically change CFUNCTYPE trick
		self.argnames = []
		self.argtypestypes = []
		for i,arg in enumerate(args):
			n,t = arg
			if n in PYTHON_RESERVED_KEYWORDS: n = 'C_'+n
			if n in self.argnames: n = '%s%s' %(n,i)
			self.argnames.append( n )
			self.argtypes.append( t )
			self.argtypestypes.append( type(t) )		# precomputed for speed

		self.argnames = tuple( self.argnames )				# should never change
		self.numargs = len( self.argtypes )
		self.callbacks = [None] * self.numargs
		self.return_wrapper = None
		self.object_oriented = False
		self.function = None
		for cdll in _CTYPES_CDLLS:	# functions could be multiple libraries
			if hasattr(cdll, self.name):
				func = self.function = getattr(cdll, self.name )
				RPYTHONIC_WRAPPER_FUNCTIONS[ name ] = self
				break
		if not self.function:
			RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES.append( name )

		if self.function: self.reset()

	def change_argument_type( self, name, t ):
		idx = self.argnames.index( name )
		self.argtypes[ idx ] = t
		self.argtypestypes[ idx ] = type(t)
		self.function.argtypes = self.argtypes

	def reset(self):
		if self.argnames:
			a = ',' + '=None,'.join( self.argnames ) + '=None'
			b = ','.join( self.argnames )
		else: a = b = ''

		callmeth = eval( 'lambda self %s: self._call_( %s )' %(a,b) )
		setattr( self.__class__, '__call__', callmeth )

		self.function.restype = self.result
		self.function.argtypes = self.argtypes

		if type( self.result ) is PyCPointerType and type(self.result._type_) is PyCStructType:
			klass = self.result._type_
			if klass not in _OOAPI_RETURNS_OBJECT_: _OOAPI_RETURNS_OBJECT_[klass] = []
			_OOAPI_RETURNS_OBJECT_[klass].append( self )

		self.defaults = []
		for i in range( self.numargs ):
			T = self.argtypes[ i ]
			if type(T) is PyCFuncPtrType:
				p = T()	# func pointers can not be None
				self.defaults.append( p )
				self.callbacks[ i ] = p					# save reference
			elif T in (ctypes.c_int, ctypes.c_uint, ctypes.c_long, ctypes.c_ulong):
				self.defaults.append( 0 )
			elif T in (ctypes.c_float, ctypes.c_double):
				self.defaults.append( .0 )
			else: self.defaults.append( None )	# None is allowed for all other types

			## generate OO API ##
			if i == 0 and type(T) is PyCPointerType and type(T._type_) is PyCStructType:
				klass = T._type_
				if klass not in _OOAPI_: _OOAPI_[ klass ] = []
				_OOAPI_[ klass ].append( self )

	def _call_( self, *args ):			# allow flexible calling types
		cargs = list( self.defaults )
		for i,arg in enumerate(args):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER
			elif hasattr( arg, '_rpythonic_' ): arg = arg.POINTER		# workaround - instance from another module

			t = type(arg)
			k = self.argtypes[ i ]
			kt = self.argtypestypes[ i ]
			if arg is None and cargs[i] is not None:	# use user defaults, very rare cases
				continue

			elif t is bool and k is ctypes.c_int:
				if arg: cargs[i] = 1	#ctypes.c_int(1)
				else: cargs[i] = 0	#ctypes.c_int(0)

			elif t in (list,tuple):				# convert lists and tuples into array
				if kt is PyCArrayType:
					cargs[ i ] = k(*arg)
				elif kt is PyCStructType:
					if k._array_wrapper_: cargs[ i ] = k(arg)	# allow easy array init
					else: cargs[ i ] = k(*arg)							# allow multiple args
				elif kt is PyCPointerType:
					cargs[ i ] = _convert_nested_list_to_pointer( k, arg )
				else: assert 0

			elif isinstance( arg, ctypes._Pointer ) and t is not k and kt is PyCPointerType:
				cargs[ i ] = ctypes.cast( arg, k )		# generic's that need to be cast

			elif kt is PyCStructType and isinstance( arg, ctypes._Pointer ):
				cargs[ i ] = arg.contents	# fixed may25

			elif kt is PyCPointerType and not isinstance( arg, (ctypes._Pointer,CArgObject) ):
				if t in (int,float,bool): ptr = k( k._type_(arg) )
				elif t is str:
					if not _ISPYTHON2: arg = arg.encode('utf-8')	# encode to ascii in python3
					ptr = ctypes.create_string_buffer(arg)				# correct and pypy compatible
				elif t in (PyCStructType, PyCArrayType):
					ptr = ctypes.cast( ctypes.pointer( arg ), k )
				else:
					ptr = arg	# TODO print warning?
				cargs[ i ] = ptr

			elif kt is PyCFuncPtrType:
				if t.__name__ == 'CFunctionType': cargs[ i ] = arg		# assume outside holds pointer
				else:													# this is not safe #
					cargs[ i ] = self.callbacks[ i ] = k( arg )				# assume arg is a callable
			else:
				cargs[ i ] = arg		# directly pass

		## if you define your own return_wrapper, it must take keyword "pointer"
		if self.return_wrapper: return self.return_wrapper( pointer=self.function( *cargs ) )
		else: return self.function( *cargs )



def _convert_nested_list_to_pointer( k, arg ):
	depth = 0; s = k
	while True:
		if type(s) is PyCPointerType:
			s = getattr( s, '_type_' )
			depth += 1
		else: break
	assert depth and depth <= 2
	if depth == 1:
		T = k._type_
		ptr = k( k._type_() )
		for i in range( len(arg) ):
			ptr[ i ] = T( *arg[i] )
	elif depth == 2:
		T = k._type_._type_
		_ptr = k._type_( k._type_._type_() )
		for i in range(len( arg )):
			for j in range( len(arg[i]) ):
				_ptr[ j ] = T( *arg[ i ][ j ] )
		ptr = k( _ptr )
	return ptr


def __freeze_rpythonic_struct( cls, fields ):
	if cls not in _OOAPI_: _OOAPI_[ cls ] = []	# wrap all structs
	try: setattr( cls, '_fields_', fields )
	except:
		print( 'WARN - bad order struct freeze', cls )
		#cls._fields_ = []

class _rpythonic_struct_( ctypes.Structure ):
	_array_wrapper_ = False
	_fields_ = []
	_methods_ = {}
	#def __call__(self): return self
	def __init__(self, *args, **kw ):
		cargs = []
		argtypes = []
		for a in self._fields_: argtypes.append( a[1] )
		if len(args) > len(argtypes): args = [args]	# allow both calling conventions
		for i,arg in enumerate( args ):
			if isinstance( arg, _rpythonic_meta_ ): arg = arg.POINTER

			t = type(arg)
			k = argtypes[ i ]
			if t in (list,tuple):
				if k.__class__.__name__	== 'PyCArrayType':
					cargs.append( k(*arg) )
				elif k.__class__.__name__ == 'PyCStructType':
					if k._array_wrapper_: cargs.append( k(arg) )	# allow easy array init
					else: cargs.append( k(*arg) )							# allow multiple args
			elif isinstance( arg, ctypes._Pointer ) and t is not k:
				cargs[ i ] = ctypes.cast( arg, k )	# generic's that need to be cast
			elif k.__class__.__name__ == 'PyCArrayType' and t in (float,int,bool):
				cargs.append( k(arg) )		# support init array from single value
			else:
				cargs.append( arg )		# directly pass

		ctypes.Structure.__init__(self, *cargs, **kw)


def _rpythonic_make_nice_global_enums_():
	G = globals()
	for name in RPYTHONIC_GLOBAL_ENUMS:
		if '_' in name and name.index('_') <= 4:
			altname = name[ name.index('_') + 1 : ]
			if altname not in G:
				G[altname] = RPYTHONIC_GLOBAL_ENUMS[ name ]

def _rpythonic_clean_up_missing_functions_():
	G = globals()
	for f in RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES:
		G.pop( f )
	print( "C functions loaded: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS) )
	print( "C functions failed: %s" %len(RPYTHONIC_WRAPPER_FUNCTIONS_FAILURES) )



###### NEW API #########
CTYPES_DLL = None

class _VOID_POINTER_CONTAINER_(object):
	def __init__(self, ptr, name=None):
		self._pointer_ = ptr
		self.name = name
NULL = _VOID_POINTER_CONTAINER_(None,'<null pointer>')


class meta:	# NEW API - allow run time switch from ctypes to rffi
	'''
	Methods:
		RPython will not allow object wrapper around a method (__call__ not allowed)
		keep C function names in list "__cfunctions__"
		rpythonic.enable_rffi( classA, classB )	
		can take advantage of methods in object-method-wrapper,
		generate rffi wrapper and set method on classA, etc.
		replaces object-method-wrapper with rffi-method

	Properties:
		CPython: obj.x=1
		RPython: obj.set_x(1)	
	'''
	METAS = []
	def __init__(self, constructors=[], methods={}, properties={}):
		#global CTYPES_DLL	# TODO update me to using _CTYPES_CDLLS
		#if not CTYPES_DLL:
		#	CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		self.constructors = constructors
		self.methods = methods
		self.properties = properties
		self.METAS.append( self )



	def __call__(self, cls ):
		print('@meta', cls )

		if not self.constructors:
			lamb = lambda s, _explicit_pointer_=None: setattr(s,'_pointer_',getattr(_explicit_pointer_,'_pointer_')) if hasattr(_explicit_pointer_,'_pointer_') else setattr(s,'_pointer_',_explicit_pointer_)
			lamb._debug = '(no constructor)'
			setattr( cls, '__init__', lamb )
		else:
			con = self._find_best_function( self.constructors )
			cfunc = self._build_cfunc( con )
			setattr( cls, '_%s'%con['name'], cfunc )
			g = self._gen_init( con )
			setattr( cls, '__init__', g )
		
		## set methods ##
		for name in self.methods:
			meth = self.methods[ name ]
			cfuncs = []
			for m in meth['functions']:
				cfunc = self._build_cfunc( m, method=True, static=meth['static'] )
				self._setup_return( cfunc, meth )
				setattr( cls, '_%s'%m['name'], cfunc )
				cfuncs.append( cfunc )

			f = self._find_best_function( meth['functions'] )
			g = self._gen_method( meth, f )
			g._cfuncs = cfuncs
			if meth['static']: g = classmethod( g )
			setattr( cls, name, g )

		for name in self.properties:
			print( 'property:', name )
			p = []
			for f in self.properties[name]:
				cfunc = self._build_cfunc( f )
				setattr( cls, '_%s'%f['name'], cfunc )
				g = self._gen_method( f, f )
				p.append( g )

			setattr( cls, name, property(*p) )

		return cls


	@staticmethod
	def _build_cfunc( info, method=False, static=False ):
		cfunc = getattr(CTYPES_DLL, info['name'])
		if method and not static: argtypes = [ ctypes.c_void_p ]
		else: argtypes = []
		for p in info['parameters']: argtypes.append( eval(p['ctypes_type']) )
		cfunc.argtypes = argtypes
		return cfunc

	@staticmethod
	def _setup_return( cfunc, info ):
		if not info['returns_fundamental']:
			cfunc.restype = ctypes.c_void_p
		elif info['returns_fundamental']:
			cfunc.restype = eval( info['returns_ctypes'] )
		else:
			cfunc.restype = ctypes.c_void_p

	@staticmethod
	def _gen_prepare_args( m ):
		a = []; b = []
		for i,p in enumerate(m['parameters']):
			if 'name' in p: n = p['name']
			else: n = '_unnamed_%s' %i
			if '<' in n: n = '_TODOfixme_%s' %i
			if n in PYTHON_RESERVED_KEYWORDS: n += str(i)
			if p['fundamental']:
				b.append( n )
				s = p['raw_type'].split()
				if 'default' in p:
					d = p['default']
					if p['raw_type'] in ('float', 'double'):
						if d.endswith('f'): d = d[:-1]
						d = d.replace(' ', '.')
						if 'e' in d: d = 0.0
						try: d = float(d)
						except: d = 0.0
					elif ('int' in s or 'size_t' in s) and not d.isdigit(): d = 0
					elif 'char' in s and '"' not in d: d = '""'
					elif d.lower() == 'false': d = False
					elif d.lower() == 'true': d = True
				elif 'char' in s: d = '""'
				elif 'float' in s or 'double' in s: d = 0.0
				elif 'size_t' in s or 'int' in s or 'long' in s or 'short' in s: d = 0
				elif p['raw_type'] == 'bool': d = False
				elif p['raw_type'] in ('void', '(template)'): d = 'NULL'
				else: print( p )
				a.append( n+'=%s' %d )

			else:
				b.append( '%s._pointer_'%n )
				a.append( n+'=NULL' )
		return a, b

	@staticmethod
	def _gen_init( m ):
		a, b = meta._gen_prepare_args( m )
		if a: e = 'lambda _py_self_, %s, _explicit_pointer_=None: ' %(','.join(a))
		else: e = 'lambda _py_self_, _explicit_pointer_=None: '
		e += 'setattr(_py_self_, "_pointer_", _py_self_._%s(%s))' %( m['name'], ','.join(b) )
		e += ' if not _explicit_pointer_ else '
		e += 'setattr(_py_self_, "_pointer_", _explicit_pointer_)'
		print( e )
		lamb = eval( e ); lamb._debug = e; lamb._introspect = m
		return lamb

	@staticmethod
	def _find_best_function( funcs ):
		best = funcs[0]
		score = -1
		if len(funcs) > 1:
			for f in funcs:
				hits = 0
				for p in f['parameters']:
					if p['fundamental']: hits += 1
				if hits and hits == len( f['parameters'] ):
					if hits > score:
						score = hits
						best = f
		return best

	@staticmethod
	def _gen_method( m, f ):
		a, b = meta._gen_prepare_args( f )
		if a: e = 'lambda _py_self_, %s: ' %(','.join(a))
		else: e = 'lambda _py_self_: '

		if 'static' in m and m['static']:	# static in c++ is like a classmethod
			c = '_py_self_._%s( %s )' %( f['name'], ','.join(b) )
		else:
			c = '_py_self_._%s( _py_self_._pointer_, %s )' %( f['name'], ','.join(b) )

		if not m['returns_fundamental']:
			if 'returns_unknown' in m or '<' in m['returns']: c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,m['returns'])
			else:
				something = m['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)

		e += c; lamb = eval( e )
		lamb._debug = e; lamb._introspect = f
		return lamb


	META_FUNCTIONS = []
	@classmethod
	def function( self, info ):
		print('@meta.function', info['name'] )
		#global CTYPES_DLL
		#if not CTYPES_DLL:
		#	CTYPES_DLL = _load_ctypes_lib( _clib_name_ )

		cfunc = self._build_cfunc( info, method=False, static=True )
		setattr( meta, '_%s'%info['name'], cfunc )
		self._setup_return( cfunc, info )
		a, b = meta._gen_prepare_args( info )
		e = 'lambda %s: ' %(','.join(a))
		c = 'meta._%s( %s )' %( info['name'], ','.join(b) )

		if not info['returns_fundamental']:
			if 'returns_unknown' in info or '<' in info['returns']:
				c = '_VOID_POINTER_CONTAINER_( %s, name="%s" )' %(c,info['returns'])
			else:
				something = info['returns'].replace('::', '.')
				c = '%s( _explicit_pointer_=%s )' %(something, c)
		e += c
		lamb = eval( e )
		lamb._debug = e
		lamb._introspect = info
		return lamb



def _rpythonic_strip_prefixes_( prefixes ):
	G = globals()
	names = list(G.keys())	# ensure list in py3
	for name in names:
		for prefix in prefixes:
			if name.startswith( prefix ):
				newname = name[ len(prefix) : ]
				if newname and newname not in G:
					G[ newname ] = G[ name ]


########################################################
##				Load Dynamic Libaries					##
def _rpythonic_load_dynamic_libraries(names):
	global _CTYPES_CDLLS
	for name in names:
		cdll = _load_ctypes_lib( name )
		if cdll:
			print('[[dynamic library loaded: %s]]' %name)
			_CTYPES_CDLLS.append( cdll )
#----------------------------------------------------------#
print( os.path.abspath( os.path.curdir ) )



_rpythonic_load_dynamic_libraries( [''] )

## macro globals ##
_UNISTD_H = 1
_XOPEN_XCU_VERSION = 4
_XOPEN_XPG2 = 1
_XOPEN_XPG3 = 1
_XOPEN_XPG4 = 1
_XOPEN_UNIX = 1
_XOPEN_CRYPT = 1
_XOPEN_ENH_I18N = 1
_XOPEN_LEGACY = 1
STDIN_FILENO = 0
STDOUT_FILENO = 1
STDERR_FILENO = 2
R_OK = 4
W_OK = 2
X_OK = 1
F_OK = 0
## enums ##
PC_LINK_MAX = 0 
PC_MAX_CANON = 1 
PC_MAX_INPUT = 2 
PC_NAME_MAX = 3 
PC_PATH_MAX = 4 
PC_PIPE_BUF = 5 
PC_CHOWN_RESTRICTED = 6 
PC_NO_TRUNC = 7 
PC_VDISABLE = 8 
PC_SYNC_IO = 9 
PC_ASYNC_IO = 10 
PC_PRIO_IO = 11 
PC_SOCK_MAXBUF = 12 
PC_FILESIZEBITS = 13 
PC_REC_INCR_XFER_SIZE = 14 
PC_REC_MAX_XFER_SIZE = 15 
PC_REC_MIN_XFER_SIZE = 16 
PC_REC_XFER_ALIGN = 17 
PC_ALLOC_SIZE_MIN = 18 
PC_SYMLINK_MAX = 19 
PC_2_SYMLINKS = 20 

SC_ARG_MAX = 0 
SC_CHILD_MAX = 1 
SC_CLK_TCK = 2 
SC_NGROUPS_MAX = 3 
SC_OPEN_MAX = 4 
SC_STREAM_MAX = 5 
SC_TZNAME_MAX = 6 
SC_JOB_CONTROL = 7 
SC_SAVED_IDS = 8 
SC_REALTIME_SIGNALS = 9 
SC_PRIORITY_SCHEDULING = 10 
SC_TIMERS = 11 
SC_ASYNCHRONOUS_IO = 12 
SC_PRIORITIZED_IO = 13 
SC_SYNCHRONIZED_IO = 14 
SC_FSYNC = 15 
SC_MAPPED_FILES = 16 
SC_MEMLOCK = 17 
SC_MEMLOCK_RANGE = 18 
SC_MEMORY_PROTECTION = 19 
SC_MESSAGE_PASSING = 20 
SC_SEMAPHORES = 21 
SC_SHARED_MEMORY_OBJECTS = 22 
SC_AIO_LISTIO_MAX = 23 
SC_AIO_MAX = 24 
SC_AIO_PRIO_DELTA_MAX = 25 
SC_DELAYTIMER_MAX = 26 
SC_MQ_OPEN_MAX = 27 
SC_MQ_PRIO_MAX = 28 
SC_VERSION = 29 
SC_PAGESIZE = 30 
SC_RTSIG_MAX = 31 
SC_SEM_NSEMS_MAX = 32 
SC_SEM_VALUE_MAX = 33 
SC_SIGQUEUE_MAX = 34 
SC_TIMER_MAX = 35 
SC_BC_BASE_MAX = 36 
SC_BC_DIM_MAX = 37 
SC_BC_SCALE_MAX = 38 
SC_BC_STRING_MAX = 39 
SC_COLL_WEIGHTS_MAX = 40 
SC_EQUIV_CLASS_MAX = 41 
SC_EXPR_NEST_MAX = 42 
SC_LINE_MAX = 43 
SC_RE_DUP_MAX = 44 
SC_CHARCLASS_NAME_MAX = 45 
SC_2_VERSION = 46 
SC_2_C_BIND = 47 
SC_2_C_DEV = 48 
SC_2_FORT_DEV = 49 
SC_2_FORT_RUN = 50 
SC_2_SW_DEV = 51 
SC_2_LOCALEDEF = 52 
SC_PII = 53 
SC_PII_XTI = 54 
SC_PII_SOCKET = 55 
SC_PII_INTERNET = 56 
SC_PII_OSI = 57 
SC_POLL = 58 
SC_SELECT = 59 
SC_UIO_MAXIOV = 60 
SC_IOV_MAX = 60 
SC_PII_INTERNET_STREAM = 61 
SC_PII_INTERNET_DGRAM = 62 
SC_PII_OSI_COTS = 63 
SC_PII_OSI_CLTS = 64 
SC_PII_OSI_M = 65 
SC_T_IOV_MAX = 66 
SC_THREADS = 67 
SC_THREAD_SAFE_FUNCTIONS = 68 
SC_GETGR_R_SIZE_MAX = 69 
SC_GETPW_R_SIZE_MAX = 70 
SC_LOGIN_NAME_MAX = 71 
SC_TTY_NAME_MAX = 72 
SC_THREAD_DESTRUCTOR_ITERATIONS = 73 
SC_THREAD_KEYS_MAX = 74 
SC_THREAD_STACK_MIN = 75 
SC_THREAD_THREADS_MAX = 76 
SC_THREAD_ATTR_STACKADDR = 77 
SC_THREAD_ATTR_STACKSIZE = 78 
SC_THREAD_PRIORITY_SCHEDULING = 79 
SC_THREAD_PRIO_INHERIT = 80 
SC_THREAD_PRIO_PROTECT = 81 
SC_THREAD_PROCESS_SHARED = 82 
SC_NPROCESSORS_CONF = 83 
SC_NPROCESSORS_ONLN = 84 
SC_PHYS_PAGES = 85 
SC_AVPHYS_PAGES = 86 
SC_ATEXIT_MAX = 87 
SC_PASS_MAX = 88 
SC_XOPEN_VERSION = 89 
SC_XOPEN_XCU_VERSION = 90 
SC_XOPEN_UNIX = 91 
SC_XOPEN_CRYPT = 92 
SC_XOPEN_ENH_I18N = 93 
SC_XOPEN_SHM = 94 
SC_2_CHAR_TERM = 95 
SC_2_C_VERSION = 96 
SC_2_UPE = 97 
SC_XOPEN_XPG2 = 98 
SC_XOPEN_XPG3 = 99 
SC_XOPEN_XPG4 = 100 
SC_CHAR_BIT = 101 
SC_CHAR_MAX = 102 
SC_CHAR_MIN = 103 
SC_INT_MAX = 104 
SC_INT_MIN = 105 
SC_LONG_BIT = 106 
SC_WORD_BIT = 107 
SC_MB_LEN_MAX = 108 
SC_NZERO = 109 
SC_SSIZE_MAX = 110 
SC_SCHAR_MAX = 111 
SC_SCHAR_MIN = 112 
SC_SHRT_MAX = 113 
SC_SHRT_MIN = 114 
SC_UCHAR_MAX = 115 
SC_UINT_MAX = 116 
SC_ULONG_MAX = 117 
SC_USHRT_MAX = 118 
SC_NL_ARGMAX = 119 
SC_NL_LANGMAX = 120 
SC_NL_MSGMAX = 121 
SC_NL_NMAX = 122 
SC_NL_SETMAX = 123 
SC_NL_TEXTMAX = 124 
SC_XBS5_ILP32_OFF32 = 125 
SC_XBS5_ILP32_OFFBIG = 126 
SC_XBS5_LP64_OFF64 = 127 
SC_XBS5_LPBIG_OFFBIG = 128 
SC_XOPEN_LEGACY = 129 
SC_XOPEN_REALTIME = 130 
SC_XOPEN_REALTIME_THREADS = 131 
SC_ADVISORY_INFO = 132 
SC_BARRIERS = 133 
SC_BASE = 134 
SC_C_LANG_SUPPORT = 135 
SC_C_LANG_SUPPORT_R = 136 
SC_CLOCK_SELECTION = 137 
SC_CPUTIME = 138 
SC_THREAD_CPUTIME = 139 
SC_DEVICE_IO = 140 
SC_DEVICE_SPECIFIC = 141 
SC_DEVICE_SPECIFIC_R = 142 
SC_FD_MGMT = 143 
SC_FIFO = 144 
SC_PIPE = 145 
SC_FILE_ATTRIBUTES = 146 
SC_FILE_LOCKING = 147 
SC_FILE_SYSTEM = 148 
SC_MONOTONIC_CLOCK = 149 
SC_MULTI_PROCESS = 150 
SC_SINGLE_PROCESS = 151 
SC_NETWORKING = 152 
SC_READER_WRITER_LOCKS = 153 
SC_SPIN_LOCKS = 154 
SC_REGEXP = 155 
SC_REGEX_VERSION = 156 
SC_SHELL = 157 
SC_SIGNALS = 158 
SC_SPAWN = 159 
SC_SPORADIC_SERVER = 160 
SC_THREAD_SPORADIC_SERVER = 161 
SC_SYSTEM_DATABASE = 162 
SC_SYSTEM_DATABASE_R = 163 
SC_TIMEOUTS = 164 
SC_TYPED_MEMORY_OBJECTS = 165 
SC_USER_GROUPS = 166 
SC_USER_GROUPS_R = 167 
SC_2_PBS = 168 
SC_2_PBS_ACCOUNTING = 169 
SC_2_PBS_LOCATE = 170 
SC_2_PBS_MESSAGE = 171 
SC_2_PBS_TRACK = 172 
SC_SYMLOOP_MAX = 173 
SC_STREAMS = 174 
SC_2_PBS_CHECKPOINT = 175 
SC_V6_ILP32_OFF32 = 176 
SC_V6_ILP32_OFFBIG = 177 
SC_V6_LP64_OFF64 = 178 
SC_V6_LPBIG_OFFBIG = 179 
SC_HOST_NAME_MAX = 180 
SC_TRACE = 181 
SC_TRACE_EVENT_FILTER = 182 
SC_TRACE_INHERIT = 183 
SC_TRACE_LOG = 184 
SC_LEVEL1_ICACHE_SIZE = 185 
SC_LEVEL1_ICACHE_ASSOC = 186 
SC_LEVEL1_ICACHE_LINESIZE = 187 
SC_LEVEL1_DCACHE_SIZE = 188 
SC_LEVEL1_DCACHE_ASSOC = 189 
SC_LEVEL1_DCACHE_LINESIZE = 190 
SC_LEVEL2_CACHE_SIZE = 191 
SC_LEVEL2_CACHE_ASSOC = 192 
SC_LEVEL2_CACHE_LINESIZE = 193 
SC_LEVEL3_CACHE_SIZE = 194 
SC_LEVEL3_CACHE_ASSOC = 195 
SC_LEVEL3_CACHE_LINESIZE = 196 
SC_LEVEL4_CACHE_SIZE = 197 
SC_LEVEL4_CACHE_ASSOC = 198 
SC_LEVEL4_CACHE_LINESIZE = 199 
SC_IPV6 = 265 
SC_RAW_SOCKETS = 266 
SC_V7_ILP32_OFF32 = 267 
SC_V7_ILP32_OFFBIG = 268 
SC_V7_LP64_OFF64 = 269 
SC_V7_LPBIG_OFFBIG = 270 
SC_SS_REPL_MAX = 271 
SC_TRACE_EVENT_NAME_MAX = 272 
SC_TRACE_NAME_MAX = 273 
SC_TRACE_SYS_MAX = 274 
SC_TRACE_USER_EVENT_MAX = 275 
SC_XOPEN_STREAMS = 276 
SC_THREAD_ROBUST_PRIO_INHERIT = 277 
SC_THREAD_ROBUST_PRIO_PROTECT = 278 

CS_PATH = 0 
CS_V6_WIDTH_RESTRICTED_ENVS = 1 
CS_GNU_LIBC_VERSION = 2 
CS_GNU_LIBPTHREAD_VERSION = 3 
CS_V5_WIDTH_RESTRICTED_ENVS = 4 
CS_V7_WIDTH_RESTRICTED_ENVS = 5 
CS_LFS_CFLAGS = 1000 
CS_LFS_LDFLAGS = 1001 
CS_LFS_LIBS = 1002 
CS_LFS_LINTFLAGS = 1003 
CS_LFS64_CFLAGS = 1004 
CS_LFS64_LDFLAGS = 1005 
CS_LFS64_LIBS = 1006 
CS_LFS64_LINTFLAGS = 1007 
CS_XBS5_ILP32_OFF32_CFLAGS = 1100 
CS_XBS5_ILP32_OFF32_LDFLAGS = 1101 
CS_XBS5_ILP32_OFF32_LIBS = 1102 
CS_XBS5_ILP32_OFF32_LINTFLAGS = 1103 
CS_XBS5_ILP32_OFFBIG_CFLAGS = 1104 
CS_XBS5_ILP32_OFFBIG_LDFLAGS = 1105 
CS_XBS5_ILP32_OFFBIG_LIBS = 1106 
CS_XBS5_ILP32_OFFBIG_LINTFLAGS = 1107 
CS_XBS5_LP64_OFF64_CFLAGS = 1108 
CS_XBS5_LP64_OFF64_LDFLAGS = 1109 
CS_XBS5_LP64_OFF64_LIBS = 1110 
CS_XBS5_LP64_OFF64_LINTFLAGS = 1111 
CS_XBS5_LPBIG_OFFBIG_CFLAGS = 1112 
CS_XBS5_LPBIG_OFFBIG_LDFLAGS = 1113 
CS_XBS5_LPBIG_OFFBIG_LIBS = 1114 
CS_XBS5_LPBIG_OFFBIG_LINTFLAGS = 1115 
CS_POSIX_V6_ILP32_OFF32_CFLAGS = 1116 
CS_POSIX_V6_ILP32_OFF32_LDFLAGS = 1117 
CS_POSIX_V6_ILP32_OFF32_LIBS = 1118 
CS_POSIX_V6_ILP32_OFF32_LINTFLAGS = 1119 
CS_POSIX_V6_ILP32_OFFBIG_CFLAGS = 1120 
CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS = 1121 
CS_POSIX_V6_ILP32_OFFBIG_LIBS = 1122 
CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS = 1123 
CS_POSIX_V6_LP64_OFF64_CFLAGS = 1124 
CS_POSIX_V6_LP64_OFF64_LDFLAGS = 1125 
CS_POSIX_V6_LP64_OFF64_LIBS = 1126 
CS_POSIX_V6_LP64_OFF64_LINTFLAGS = 1127 
CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS = 1128 
CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS = 1129 
CS_POSIX_V6_LPBIG_OFFBIG_LIBS = 1130 
CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS = 1131 
CS_POSIX_V7_ILP32_OFF32_CFLAGS = 1132 
CS_POSIX_V7_ILP32_OFF32_LDFLAGS = 1133 
CS_POSIX_V7_ILP32_OFF32_LIBS = 1134 
CS_POSIX_V7_ILP32_OFF32_LINTFLAGS = 1135 
CS_POSIX_V7_ILP32_OFFBIG_CFLAGS = 1136 
CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS = 1137 
CS_POSIX_V7_ILP32_OFFBIG_LIBS = 1138 
CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS = 1139 
CS_POSIX_V7_LP64_OFF64_CFLAGS = 1140 
CS_POSIX_V7_LP64_OFF64_LDFLAGS = 1141 
CS_POSIX_V7_LP64_OFF64_LIBS = 1142 
CS_POSIX_V7_LP64_OFF64_LINTFLAGS = 1143 
CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS = 1144 
CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS = 1145 
CS_POSIX_V7_LPBIG_OFFBIG_LIBS = 1146 
CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS = 1147 
CS_V6_ENV = 1148 
CS_V7_ENV = 1149 

## simple enums ##
RPYTHONIC_GLOBAL_ENUMS = { 
 "PC_LINK_MAX" : 0,  "PC_MAX_CANON" : 1,  "PC_MAX_INPUT" : 2,  "PC_NAME_MAX" : 3,  "PC_PATH_MAX" : 4,  "PC_PIPE_BUF" : 5,  "PC_CHOWN_RESTRICTED" : 6,  "PC_NO_TRUNC" : 7,  "PC_VDISABLE" : 8,  "PC_SYNC_IO" : 9,  "PC_ASYNC_IO" : 10,  "PC_PRIO_IO" : 11,  "PC_SOCK_MAXBUF" : 12,  "PC_FILESIZEBITS" : 13,  "PC_REC_INCR_XFER_SIZE" : 14,  "PC_REC_MAX_XFER_SIZE" : 15,  "PC_REC_MIN_XFER_SIZE" : 16,  "PC_REC_XFER_ALIGN" : 17,  "PC_ALLOC_SIZE_MIN" : 18,  "PC_SYMLINK_MAX" : 19,  "PC_2_SYMLINKS" : 20, 
 "SC_ARG_MAX" : 0,  "SC_CHILD_MAX" : 1,  "SC_CLK_TCK" : 2,  "SC_NGROUPS_MAX" : 3,  "SC_OPEN_MAX" : 4,  "SC_STREAM_MAX" : 5,  "SC_TZNAME_MAX" : 6,  "SC_JOB_CONTROL" : 7,  "SC_SAVED_IDS" : 8,  "SC_REALTIME_SIGNALS" : 9,  "SC_PRIORITY_SCHEDULING" : 10,  "SC_TIMERS" : 11,  "SC_ASYNCHRONOUS_IO" : 12,  "SC_PRIORITIZED_IO" : 13,  "SC_SYNCHRONIZED_IO" : 14,  "SC_FSYNC" : 15,  "SC_MAPPED_FILES" : 16,  "SC_MEMLOCK" : 17,  "SC_MEMLOCK_RANGE" : 18,  "SC_MEMORY_PROTECTION" : 19,  "SC_MESSAGE_PASSING" : 20,  "SC_SEMAPHORES" : 21,  "SC_SHARED_MEMORY_OBJECTS" : 22,  "SC_AIO_LISTIO_MAX" : 23,  "SC_AIO_MAX" : 24,  "SC_AIO_PRIO_DELTA_MAX" : 25,  "SC_DELAYTIMER_MAX" : 26,  "SC_MQ_OPEN_MAX" : 27,  "SC_MQ_PRIO_MAX" : 28,  "SC_VERSION" : 29,  "SC_PAGESIZE" : 30,  "SC_RTSIG_MAX" : 31,  "SC_SEM_NSEMS_MAX" : 32,  "SC_SEM_VALUE_MAX" : 33,  "SC_SIGQUEUE_MAX" : 34,  "SC_TIMER_MAX" : 35,  "SC_BC_BASE_MAX" : 36,  "SC_BC_DIM_MAX" : 37,  "SC_BC_SCALE_MAX" : 38,  "SC_BC_STRING_MAX" : 39,  "SC_COLL_WEIGHTS_MAX" : 40,  "SC_EQUIV_CLASS_MAX" : 41,  "SC_EXPR_NEST_MAX" : 42,  "SC_LINE_MAX" : 43,  "SC_RE_DUP_MAX" : 44,  "SC_CHARCLASS_NAME_MAX" : 45,  "SC_2_VERSION" : 46,  "SC_2_C_BIND" : 47,  "SC_2_C_DEV" : 48,  "SC_2_FORT_DEV" : 49,  "SC_2_FORT_RUN" : 50,  "SC_2_SW_DEV" : 51,  "SC_2_LOCALEDEF" : 52,  "SC_PII" : 53,  "SC_PII_XTI" : 54,  "SC_PII_SOCKET" : 55,  "SC_PII_INTERNET" : 56,  "SC_PII_OSI" : 57,  "SC_POLL" : 58,  "SC_SELECT" : 59,  "SC_UIO_MAXIOV" : 60,  "SC_IOV_MAX" : 60,  "SC_PII_INTERNET_STREAM" : 61,  "SC_PII_INTERNET_DGRAM" : 62,  "SC_PII_OSI_COTS" : 63,  "SC_PII_OSI_CLTS" : 64,  "SC_PII_OSI_M" : 65,  "SC_T_IOV_MAX" : 66,  "SC_THREADS" : 67,  "SC_THREAD_SAFE_FUNCTIONS" : 68,  "SC_GETGR_R_SIZE_MAX" : 69,  "SC_GETPW_R_SIZE_MAX" : 70,  "SC_LOGIN_NAME_MAX" : 71,  "SC_TTY_NAME_MAX" : 72,  "SC_THREAD_DESTRUCTOR_ITERATIONS" : 73,  "SC_THREAD_KEYS_MAX" : 74,  "SC_THREAD_STACK_MIN" : 75,  "SC_THREAD_THREADS_MAX" : 76,  "SC_THREAD_ATTR_STACKADDR" : 77,  "SC_THREAD_ATTR_STACKSIZE" : 78,  "SC_THREAD_PRIORITY_SCHEDULING" : 79,  "SC_THREAD_PRIO_INHERIT" : 80,  "SC_THREAD_PRIO_PROTECT" : 81,  "SC_THREAD_PROCESS_SHARED" : 82,  "SC_NPROCESSORS_CONF" : 83,  "SC_NPROCESSORS_ONLN" : 84,  "SC_PHYS_PAGES" : 85,  "SC_AVPHYS_PAGES" : 86,  "SC_ATEXIT_MAX" : 87,  "SC_PASS_MAX" : 88,  "SC_XOPEN_VERSION" : 89,  "SC_XOPEN_XCU_VERSION" : 90,  "SC_XOPEN_UNIX" : 91,  "SC_XOPEN_CRYPT" : 92,  "SC_XOPEN_ENH_I18N" : 93,  "SC_XOPEN_SHM" : 94,  "SC_2_CHAR_TERM" : 95,  "SC_2_C_VERSION" : 96,  "SC_2_UPE" : 97,  "SC_XOPEN_XPG2" : 98,  "SC_XOPEN_XPG3" : 99,  "SC_XOPEN_XPG4" : 100,  "SC_CHAR_BIT" : 101,  "SC_CHAR_MAX" : 102,  "SC_CHAR_MIN" : 103,  "SC_INT_MAX" : 104,  "SC_INT_MIN" : 105,  "SC_LONG_BIT" : 106,  "SC_WORD_BIT" : 107,  "SC_MB_LEN_MAX" : 108,  "SC_NZERO" : 109,  "SC_SSIZE_MAX" : 110,  "SC_SCHAR_MAX" : 111,  "SC_SCHAR_MIN" : 112,  "SC_SHRT_MAX" : 113,  "SC_SHRT_MIN" : 114,  "SC_UCHAR_MAX" : 115,  "SC_UINT_MAX" : 116,  "SC_ULONG_MAX" : 117,  "SC_USHRT_MAX" : 118,  "SC_NL_ARGMAX" : 119,  "SC_NL_LANGMAX" : 120,  "SC_NL_MSGMAX" : 121,  "SC_NL_NMAX" : 122,  "SC_NL_SETMAX" : 123,  "SC_NL_TEXTMAX" : 124,  "SC_XBS5_ILP32_OFF32" : 125,  "SC_XBS5_ILP32_OFFBIG" : 126,  "SC_XBS5_LP64_OFF64" : 127,  "SC_XBS5_LPBIG_OFFBIG" : 128,  "SC_XOPEN_LEGACY" : 129,  "SC_XOPEN_REALTIME" : 130,  "SC_XOPEN_REALTIME_THREADS" : 131,  "SC_ADVISORY_INFO" : 132,  "SC_BARRIERS" : 133,  "SC_BASE" : 134,  "SC_C_LANG_SUPPORT" : 135,  "SC_C_LANG_SUPPORT_R" : 136,  "SC_CLOCK_SELECTION" : 137,  "SC_CPUTIME" : 138,  "SC_THREAD_CPUTIME" : 139,  "SC_DEVICE_IO" : 140,  "SC_DEVICE_SPECIFIC" : 141,  "SC_DEVICE_SPECIFIC_R" : 142,  "SC_FD_MGMT" : 143,  "SC_FIFO" : 144,  "SC_PIPE" : 145,  "SC_FILE_ATTRIBUTES" : 146,  "SC_FILE_LOCKING" : 147,  "SC_FILE_SYSTEM" : 148,  "SC_MONOTONIC_CLOCK" : 149,  "SC_MULTI_PROCESS" : 150,  "SC_SINGLE_PROCESS" : 151,  "SC_NETWORKING" : 152,  "SC_READER_WRITER_LOCKS" : 153,  "SC_SPIN_LOCKS" : 154,  "SC_REGEXP" : 155,  "SC_REGEX_VERSION" : 156,  "SC_SHELL" : 157,  "SC_SIGNALS" : 158,  "SC_SPAWN" : 159,  "SC_SPORADIC_SERVER" : 160,  "SC_THREAD_SPORADIC_SERVER" : 161,  "SC_SYSTEM_DATABASE" : 162,  "SC_SYSTEM_DATABASE_R" : 163,  "SC_TIMEOUTS" : 164,  "SC_TYPED_MEMORY_OBJECTS" : 165,  "SC_USER_GROUPS" : 166,  "SC_USER_GROUPS_R" : 167,  "SC_2_PBS" : 168,  "SC_2_PBS_ACCOUNTING" : 169,  "SC_2_PBS_LOCATE" : 170,  "SC_2_PBS_MESSAGE" : 171,  "SC_2_PBS_TRACK" : 172,  "SC_SYMLOOP_MAX" : 173,  "SC_STREAMS" : 174,  "SC_2_PBS_CHECKPOINT" : 175,  "SC_V6_ILP32_OFF32" : 176,  "SC_V6_ILP32_OFFBIG" : 177,  "SC_V6_LP64_OFF64" : 178,  "SC_V6_LPBIG_OFFBIG" : 179,  "SC_HOST_NAME_MAX" : 180,  "SC_TRACE" : 181,  "SC_TRACE_EVENT_FILTER" : 182,  "SC_TRACE_INHERIT" : 183,  "SC_TRACE_LOG" : 184,  "SC_LEVEL1_ICACHE_SIZE" : 185,  "SC_LEVEL1_ICACHE_ASSOC" : 186,  "SC_LEVEL1_ICACHE_LINESIZE" : 187,  "SC_LEVEL1_DCACHE_SIZE" : 188,  "SC_LEVEL1_DCACHE_ASSOC" : 189,  "SC_LEVEL1_DCACHE_LINESIZE" : 190,  "SC_LEVEL2_CACHE_SIZE" : 191,  "SC_LEVEL2_CACHE_ASSOC" : 192,  "SC_LEVEL2_CACHE_LINESIZE" : 193,  "SC_LEVEL3_CACHE_SIZE" : 194,  "SC_LEVEL3_CACHE_ASSOC" : 195,  "SC_LEVEL3_CACHE_LINESIZE" : 196,  "SC_LEVEL4_CACHE_SIZE" : 197,  "SC_LEVEL4_CACHE_ASSOC" : 198,  "SC_LEVEL4_CACHE_LINESIZE" : 199,  "SC_IPV6" : 265,  "SC_RAW_SOCKETS" : 266,  "SC_V7_ILP32_OFF32" : 267,  "SC_V7_ILP32_OFFBIG" : 268,  "SC_V7_LP64_OFF64" : 269,  "SC_V7_LPBIG_OFFBIG" : 270,  "SC_SS_REPL_MAX" : 271,  "SC_TRACE_EVENT_NAME_MAX" : 272,  "SC_TRACE_NAME_MAX" : 273,  "SC_TRACE_SYS_MAX" : 274,  "SC_TRACE_USER_EVENT_MAX" : 275,  "SC_XOPEN_STREAMS" : 276,  "SC_THREAD_ROBUST_PRIO_INHERIT" : 277,  "SC_THREAD_ROBUST_PRIO_PROTECT" : 278, 
 "CS_PATH" : 0,  "CS_V6_WIDTH_RESTRICTED_ENVS" : 1,  "CS_GNU_LIBC_VERSION" : 2,  "CS_GNU_LIBPTHREAD_VERSION" : 3,  "CS_V5_WIDTH_RESTRICTED_ENVS" : 4,  "CS_V7_WIDTH_RESTRICTED_ENVS" : 5,  "CS_LFS_CFLAGS" : 1000,  "CS_LFS_LDFLAGS" : 1001,  "CS_LFS_LIBS" : 1002,  "CS_LFS_LINTFLAGS" : 1003,  "CS_LFS64_CFLAGS" : 1004,  "CS_LFS64_LDFLAGS" : 1005,  "CS_LFS64_LIBS" : 1006,  "CS_LFS64_LINTFLAGS" : 1007,  "CS_XBS5_ILP32_OFF32_CFLAGS" : 1100,  "CS_XBS5_ILP32_OFF32_LDFLAGS" : 1101,  "CS_XBS5_ILP32_OFF32_LIBS" : 1102,  "CS_XBS5_ILP32_OFF32_LINTFLAGS" : 1103,  "CS_XBS5_ILP32_OFFBIG_CFLAGS" : 1104,  "CS_XBS5_ILP32_OFFBIG_LDFLAGS" : 1105,  "CS_XBS5_ILP32_OFFBIG_LIBS" : 1106,  "CS_XBS5_ILP32_OFFBIG_LINTFLAGS" : 1107,  "CS_XBS5_LP64_OFF64_CFLAGS" : 1108,  "CS_XBS5_LP64_OFF64_LDFLAGS" : 1109,  "CS_XBS5_LP64_OFF64_LIBS" : 1110,  "CS_XBS5_LP64_OFF64_LINTFLAGS" : 1111,  "CS_XBS5_LPBIG_OFFBIG_CFLAGS" : 1112,  "CS_XBS5_LPBIG_OFFBIG_LDFLAGS" : 1113,  "CS_XBS5_LPBIG_OFFBIG_LIBS" : 1114,  "CS_XBS5_LPBIG_OFFBIG_LINTFLAGS" : 1115,  "CS_POSIX_V6_ILP32_OFF32_CFLAGS" : 1116,  "CS_POSIX_V6_ILP32_OFF32_LDFLAGS" : 1117,  "CS_POSIX_V6_ILP32_OFF32_LIBS" : 1118,  "CS_POSIX_V6_ILP32_OFF32_LINTFLAGS" : 1119,  "CS_POSIX_V6_ILP32_OFFBIG_CFLAGS" : 1120,  "CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS" : 1121,  "CS_POSIX_V6_ILP32_OFFBIG_LIBS" : 1122,  "CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS" : 1123,  "CS_POSIX_V6_LP64_OFF64_CFLAGS" : 1124,  "CS_POSIX_V6_LP64_OFF64_LDFLAGS" : 1125,  "CS_POSIX_V6_LP64_OFF64_LIBS" : 1126,  "CS_POSIX_V6_LP64_OFF64_LINTFLAGS" : 1127,  "CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS" : 1128,  "CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS" : 1129,  "CS_POSIX_V6_LPBIG_OFFBIG_LIBS" : 1130,  "CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS" : 1131,  "CS_POSIX_V7_ILP32_OFF32_CFLAGS" : 1132,  "CS_POSIX_V7_ILP32_OFF32_LDFLAGS" : 1133,  "CS_POSIX_V7_ILP32_OFF32_LIBS" : 1134,  "CS_POSIX_V7_ILP32_OFF32_LINTFLAGS" : 1135,  "CS_POSIX_V7_ILP32_OFFBIG_CFLAGS" : 1136,  "CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS" : 1137,  "CS_POSIX_V7_ILP32_OFFBIG_LIBS" : 1138,  "CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS" : 1139,  "CS_POSIX_V7_LP64_OFF64_CFLAGS" : 1140,  "CS_POSIX_V7_LP64_OFF64_LDFLAGS" : 1141,  "CS_POSIX_V7_LP64_OFF64_LIBS" : 1142,  "CS_POSIX_V7_LP64_OFF64_LINTFLAGS" : 1143,  "CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS" : 1144,  "CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS" : 1145,  "CS_POSIX_V7_LPBIG_OFFBIG_LIBS" : 1146,  "CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS" : 1147,  "CS_V6_ENV" : 1148,  "CS_V7_ENV" : 1149, 

}
class __fsid_t(_rpythonic_struct_): _array_wrapper_ = True
## union and structures ##
__freeze_rpythonic_struct( __fsid_t, [
	( "__val", ( ctypes.c_int * 2 ) ),
])

## wrapper functions ##
access = _rpythonic_function_(		"access", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),
	("__type",		ctypes.c_int),] )

faccessat = _rpythonic_function_(		"faccessat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__type",		ctypes.c_int),
	("__flag",		ctypes.c_int),] )

lseek = _rpythonic_function_(		"lseek", ctypes.c_int64, [
	("__fd",		ctypes.c_int),
	("__offset",		ctypes.c_int64),
	("__whence",		ctypes.c_int),] )

close = _rpythonic_function_(		"close", ctypes.c_int, [
	("__fd",		ctypes.c_int),] )

read = _rpythonic_function_(		"read", ctypes.c_int64, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__nbytes",		ctypes.c_uint64),] )

write = _rpythonic_function_(		"write", ctypes.c_int64, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint64),] )

pread = _rpythonic_function_(		"pread", ctypes.c_int64, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__nbytes",		ctypes.c_uint64),
	("__offset",		ctypes.c_int64),] )

execv = _rpythonic_function_(		"execv", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__argv",		ctypes.c_char),] )

execvp = _rpythonic_function_(		"execvp", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__argv",		ctypes.c_char),] )

nice = _rpythonic_function_(		"nice", ctypes.c_int, [
	("__inc",		ctypes.c_int),] )

_exit = _rpythonic_function_(		"_exit", ctypes.c_void_p, [
	("__status",		ctypes.c_int),] )

pathconf = _rpythonic_function_(		"pathconf", ctypes.c_int64, [
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__name",		ctypes.c_int),] )

fpathconf = _rpythonic_function_(		"fpathconf", ctypes.c_int64, [
	("__fd",		ctypes.c_int),
	("__name",		ctypes.c_int),] )

gethostname = _rpythonic_function_(		"gethostname", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),
	("__len",		ctypes.c_uint64),] )

sethostname = _rpythonic_function_(		"sethostname", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),
	("__len",		ctypes.c_uint64),] )

sethostid = _rpythonic_function_(		"sethostid", ctypes.c_int, [
	("__id",		ctypes.c_int64),] )

getdomainname = _rpythonic_function_(		"getdomainname", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),
	("__len",		ctypes.c_uint64),] )

setdomainname = _rpythonic_function_(		"setdomainname", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),
	("__len",		ctypes.c_uint64),] )

unlink = _rpythonic_function_(		"unlink", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),] )

unlinkat = _rpythonic_function_(		"unlinkat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__name",		ctypes.POINTER(ctypes.c_char)),
	("__flag",		ctypes.c_int),] )

rmdir = _rpythonic_function_(		"rmdir", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),] )

tcgetpgrp = _rpythonic_function_(		"tcgetpgrp", ctypes.c_int, [
	("__fd",		ctypes.c_int),] )

tcsetpgrp = _rpythonic_function_(		"tcsetpgrp", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__pgrp_id",		ctypes.c_int),] )

getpgid = _rpythonic_function_(		"getpgid", ctypes.c_int, [
	("__pid",		ctypes.c_int),] )

setpgid = _rpythonic_function_(		"setpgid", ctypes.c_int, [
	("__pid",		ctypes.c_int),
	("__pgid",		ctypes.c_int),] )

setpgrp = _rpythonic_function_(		"setpgrp", ctypes.c_int, [] )

setsid = _rpythonic_function_(		"setsid", ctypes.c_int, [] )

getsid = _rpythonic_function_(		"getsid", ctypes.c_int, [
	("__pid",		ctypes.c_int),] )

getuid = _rpythonic_function_(		"getuid", ctypes.c_uint, [] )

geteuid = _rpythonic_function_(		"geteuid", ctypes.c_uint, [] )

getgid = _rpythonic_function_(		"getgid", ctypes.c_uint, [] )

getegid = _rpythonic_function_(		"getegid", ctypes.c_uint, [] )

getgroups = _rpythonic_function_(		"getgroups", ctypes.c_int, [
	("__size",		ctypes.c_int),
	("__list",		ctypes.c_uint),] )

setuid = _rpythonic_function_(		"setuid", ctypes.c_int, [
	("__uid",		ctypes.c_uint),] )

setreuid = _rpythonic_function_(		"setreuid", ctypes.c_int, [
	("__ruid",		ctypes.c_uint),
	("__euid",		ctypes.c_uint),] )

seteuid = _rpythonic_function_(		"seteuid", ctypes.c_int, [
	("__uid",		ctypes.c_uint),] )

getwd = _rpythonic_function_(		"getwd", ctypes.POINTER(ctypes.c_char), [
	("__buf",		ctypes.POINTER(ctypes.c_char)),] )

dup = _rpythonic_function_(		"dup", ctypes.c_int, [
	("__fd",		ctypes.c_int),] )

dup2 = _rpythonic_function_(		"dup2", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__fd2",		ctypes.c_int),] )

execve = _rpythonic_function_(		"execve", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__argv",		ctypes.c_char),
	("__envp",		ctypes.c_char),] )

fexecve = _rpythonic_function_(		"fexecve", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__argv",		ctypes.c_char),
	("__envp",		ctypes.c_char),] )

ttyname_r = _rpythonic_function_(		"ttyname_r", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__buflen",		ctypes.c_uint64),] )

isatty = _rpythonic_function_(		"isatty", ctypes.c_int, [
	("__fd",		ctypes.c_int),] )

ttyslot = _rpythonic_function_(		"ttyslot", ctypes.c_int, [] )

link = _rpythonic_function_(		"link", ctypes.c_int, [
	("__from",		ctypes.POINTER(ctypes.c_char)),
	("__to",		ctypes.POINTER(ctypes.c_char)),] )

linkat = _rpythonic_function_(		"linkat", ctypes.c_int, [
	("__fromfd",		ctypes.c_int),
	("__from",		ctypes.POINTER(ctypes.c_char)),
	("__tofd",		ctypes.c_int),
	("__to",		ctypes.POINTER(ctypes.c_char)),
	("__flags",		ctypes.c_int),] )

sysconf = _rpythonic_function_(		"sysconf", ctypes.c_int64, [
	("__name",		ctypes.c_int),] )

confstr = _rpythonic_function_(		"confstr", ctypes.c_uint64, [
	("__name",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__len",		ctypes.c_uint64),] )

getpid = _rpythonic_function_(		"getpid", ctypes.c_int, [] )

getppid = _rpythonic_function_(		"getppid", ctypes.c_int, [] )

getpgrp = _rpythonic_function_(		"getpgrp", ctypes.c_int, [] )

pwrite = _rpythonic_function_(		"pwrite", ctypes.c_int64, [
	("__fd",		ctypes.c_int),
	("__buf",		ctypes.POINTER(ctypes.c_void_p)),
	("__n",		ctypes.c_uint64),
	("__offset",		ctypes.c_int64),] )

pipe = _rpythonic_function_(		"pipe", ctypes.c_int, [
	("__pipedes",		( ctypes.c_int * 2 )),] )

alarm = _rpythonic_function_(		"alarm", ctypes.c_uint, [
	("__seconds",		ctypes.c_uint),] )

sleep = _rpythonic_function_(		"sleep", ctypes.c_uint, [
	("__seconds",		ctypes.c_uint),] )

ualarm = _rpythonic_function_(		"ualarm", ctypes.c_uint, [
	("__value",		ctypes.c_uint),
	("__interval",		ctypes.c_uint),] )

setgid = _rpythonic_function_(		"setgid", ctypes.c_int, [
	("__gid",		ctypes.c_uint),] )

setregid = _rpythonic_function_(		"setregid", ctypes.c_int, [
	("__rgid",		ctypes.c_uint),
	("__egid",		ctypes.c_uint),] )

setegid = _rpythonic_function_(		"setegid", ctypes.c_int, [
	("__gid",		ctypes.c_uint),] )

fork = _rpythonic_function_(		"fork", ctypes.c_int, [] )

vfork = _rpythonic_function_(		"vfork", ctypes.c_int, [] )

ttyname = _rpythonic_function_(		"ttyname", ctypes.POINTER(ctypes.c_char), [
	("__fd",		ctypes.c_int),] )

getlogin = _rpythonic_function_(		"getlogin", ctypes.POINTER(ctypes.c_char), [] )

getlogin_r = _rpythonic_function_(		"getlogin_r", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),
	("__name_len",		ctypes.c_uint64),] )

setlogin = _rpythonic_function_(		"setlogin", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),] )

getopt = _rpythonic_function_(		"getopt", ctypes.c_int, [
	("___argc",		ctypes.c_int),
	("___argv",		ctypes.POINTER(ctypes.POINTER(ctypes.c_char))),
	("__shortopts",		ctypes.POINTER(ctypes.c_char)),] )

symlink = _rpythonic_function_(		"symlink", ctypes.c_int, [
	("__from",		ctypes.POINTER(ctypes.c_char)),
	("__to",		ctypes.POINTER(ctypes.c_char)),] )

readlink = _rpythonic_function_(		"readlink", ctypes.c_int64, [
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__len",		ctypes.c_uint64),] )

symlinkat = _rpythonic_function_(		"symlinkat", ctypes.c_int, [
	("__from",		ctypes.POINTER(ctypes.c_char)),
	("__tofd",		ctypes.c_int),
	("__to",		ctypes.POINTER(ctypes.c_char)),] )

readlinkat = _rpythonic_function_(		"readlinkat", ctypes.c_int64, [
	("__fd",		ctypes.c_int),
	("__path",		ctypes.POINTER(ctypes.c_char)),
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__len",		ctypes.c_uint64),] )

fchownat = _rpythonic_function_(		"fchownat", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__owner",		ctypes.c_uint),
	("__group",		ctypes.c_uint),
	("__flag",		ctypes.c_int),] )

chdir = _rpythonic_function_(		"chdir", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),] )

fchdir = _rpythonic_function_(		"fchdir", ctypes.c_int, [
	("__fd",		ctypes.c_int),] )

getcwd = _rpythonic_function_(		"getcwd", ctypes.POINTER(ctypes.c_char), [
	("__buf",		ctypes.POINTER(ctypes.c_char)),
	("__size",		ctypes.c_uint64),] )

usleep = _rpythonic_function_(		"usleep", ctypes.c_int, [
	("__useconds",		ctypes.c_uint),] )

pause = _rpythonic_function_(		"pause", ctypes.c_int, [] )

chown = _rpythonic_function_(		"chown", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__owner",		ctypes.c_uint),
	("__group",		ctypes.c_uint),] )

fchown = _rpythonic_function_(		"fchown", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__owner",		ctypes.c_uint),
	("__group",		ctypes.c_uint),] )

lchown = _rpythonic_function_(		"lchown", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__owner",		ctypes.c_uint),
	("__group",		ctypes.c_uint),] )

vhangup = _rpythonic_function_(		"vhangup", ctypes.c_int, [] )

revoke = _rpythonic_function_(		"revoke", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),] )

profil = _rpythonic_function_(		"profil", ctypes.c_int, [
	("__sample_buffer",		ctypes.POINTER(ctypes.c_uint16)),
	("__size",		ctypes.c_uint64),
	("__offset",		ctypes.c_uint64),
	("__scale",		ctypes.c_uint),] )

acct = _rpythonic_function_(		"acct", ctypes.c_int, [
	("__name",		ctypes.POINTER(ctypes.c_char)),] )

getusershell = _rpythonic_function_(		"getusershell", ctypes.POINTER(ctypes.c_char), [] )

gethostid = _rpythonic_function_(		"gethostid", ctypes.c_int64, [] )

sync = _rpythonic_function_(		"sync", ctypes.c_void_p, [] )

getpagesize = _rpythonic_function_(		"getpagesize", ctypes.c_int, [] )

getdtablesize = _rpythonic_function_(		"getdtablesize", ctypes.c_int, [] )

truncate = _rpythonic_function_(		"truncate", ctypes.c_int, [
	("__file",		ctypes.POINTER(ctypes.c_char)),
	("__length",		ctypes.c_int64),] )

ftruncate = _rpythonic_function_(		"ftruncate", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__length",		ctypes.c_int64),] )

brk = _rpythonic_function_(		"brk", ctypes.c_int, [("__addr",		ctypes.c_void_p)] )

sbrk = _rpythonic_function_(		"sbrk", ctypes.POINTER(ctypes.c_void_p), [
	("__delta",		ctypes.c_int64),] )

lockf = _rpythonic_function_(		"lockf", ctypes.c_int, [
	("__fd",		ctypes.c_int),
	("__cmd",		ctypes.c_int),
	("__len",		ctypes.c_int64),] )

fdatasync = _rpythonic_function_(		"fdatasync", ctypes.c_int, [
	("__fildes",		ctypes.c_int),] )

ctermid = _rpythonic_function_(		"ctermid", ctypes.POINTER(ctypes.c_char), [
	("__s",		ctypes.POINTER(ctypes.c_char)),] )

endusershell = _rpythonic_function_(		"endusershell", ctypes.c_void_p, [] )

setusershell = _rpythonic_function_(		"setusershell", ctypes.c_void_p, [] )

daemon = _rpythonic_function_(		"daemon", ctypes.c_int, [
	("__nochdir",		ctypes.c_int),
	("__noclose",		ctypes.c_int),] )

chroot = _rpythonic_function_(		"chroot", ctypes.c_int, [
	("__path",		ctypes.POINTER(ctypes.c_char)),] )

getpass = _rpythonic_function_(		"getpass", ctypes.POINTER(ctypes.c_char), [
	("__prompt",		ctypes.POINTER(ctypes.c_char)),] )

fsync = _rpythonic_function_(		"fsync", ctypes.c_int, [
	("__fd",		ctypes.c_int),] )


_rpythonic_convert_structs_to_objects()

_rpythonic_setup_return_wrappers()
_rpythonic_make_nice_global_enums_()
_rpythonic_clean_up_missing_functions_()